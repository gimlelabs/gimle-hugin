name: Auto bump patch tag

on:
  push:
    branches:
      - main

permissions:
  contents: write

concurrency:
  group: auto-bump-patch-tag
  cancel-in-progress: false

jobs:
  bump:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --force --tags

      - name: Skip if HEAD already has a version tag
        id: head_tag
        run: |
          set -euo pipefail
          if git tag --points-at HEAD | grep -Eq '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "has_tag=true" >> "$GITHUB_OUTPUT"
            echo "HEAD is already tagged; skipping."
          else
            echo "has_tag=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Compute next patch tag
        if: steps.head_tag.outputs.has_tag != 'true'
        id: next
        run: |
          set -euo pipefail
          latest="$(git describe --tags --match 'v[0-9]*.[0-9]*.[0-9]*' --abbrev=0 2>/dev/null || echo 'v0.0.0')"
          ver="${latest#v}"
          IFS='.' read -r major minor patch <<< "${ver}"
          major="${major:-0}"
          minor="${minor:-0}"
          patch="${patch:-0}"
          next="v${major}.${minor}.$((patch + 1))"
          echo "latest=${latest}" >> "$GITHUB_OUTPUT"
          echo "tag=${next}" >> "$GITHUB_OUTPUT"
          echo "Latest tag: ${latest}"
          echo "Next tag:   ${next}"

      - name: Create and push tag
        if: steps.head_tag.outputs.has_tag != 'true'
        run: |
          set -euo pipefail
          git tag "${{ steps.next.outputs.tag }}"
          git push origin "${{ steps.next.outputs.tag }}"
