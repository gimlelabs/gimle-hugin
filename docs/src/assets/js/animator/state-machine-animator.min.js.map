{
  "version": 3,
  "sources": ["../src/index.ts", "../src/core/types.ts", "../src/utils/colors.ts", "../src/utils/layout.ts", "../src/renderers/SVGRenderer.ts", "../src/core/Animator.ts", "../src/utils/easing.ts"],
  "sourcesContent": ["/**\n * State Machine Animator\n *\n * A library for creating animated visualizations of state machines\n * and interaction stacks, designed for documentation and educational content.\n *\n * @example\n * ```typescript\n * import { StateMachineAnimator } from '@gimle/state-machine-animator';\n *\n * const animator = new StateMachineAnimator({\n *   container: '#animation-container',\n *   theme: 'light',\n * });\n *\n * await animator.playToolExecution({\n *   stack: { id: 'main', label: 'Agent', states: [] },\n *   triggerState: { type: 'ToolCall', label: 'search' },\n *   tool: { id: 'search', name: 'Search', icon: '\uD83D\uDD0D' },\n *   resultState: { type: 'ToolResult', label: 'Found 10 results' },\n * });\n * ```\n */\n\n// Core exports\nexport { StateMachineAnimator } from './core/Animator.js';\nexport {\n  getStateCategory,\n  type StateType,\n  type StateCategory,\n  type StateConfig,\n  type StackConfig,\n  type ToolConfig,\n  type ArtifactConfig,\n  type AnimationConfig,\n  type ThemeConfig,\n  type RendererConfig,\n  type EasingFunction,\n  type EasingPreset,\n  type ToolExecutionAnimation,\n  type ArtifactCreationAnimation,\n  type TransitionDiagramAnimation,\n  type BranchAnimation,\n  type MultiStackInteraction,\n  type AnimatorEvent,\n  type AnimatorEventCallback,\n  type Point,\n  type Rect,\n  type ArrowOptions,\n  type ElementRef,\n} from './core/types.js';\n\n// Renderer exports\nexport { SVGRenderer } from './renderers/SVGRenderer.js';\n\n// Utility exports\nexport {\n  lightTheme,\n  darkTheme,\n  getTheme,\n  getStateColors,\n  categoryLabels,\n} from './utils/colors.js';\n\nexport {\n  linear,\n  easeIn,\n  easeOut,\n  easeInOut,\n  easeInQuad,\n  easeOutQuad,\n  easeInOutQuad,\n  easeInCubic,\n  easeOutCubic,\n  easeInOutCubic,\n  easeInBack,\n  easeOutBack,\n  easeInOutBack,\n  easeOutBounce,\n  easeInBounce,\n  getEasing,\n  easingPresets,\n} from './utils/easing.js';\n\nexport { dimensions } from './utils/layout.js';\n", "/**\n * Core type definitions for the State Machine Animator\n *\n * These types align with the Hugin agent framework's interaction model\n * while providing flexibility for custom visualizations.\n */\n\n// =============================================================================\n// State Types\n// =============================================================================\n\n/**\n * Standard state types from the Hugin framework.\n * Maps to interaction types in the Python codebase.\n */\nexport type StateType =\n  // Task Interactions\n  | 'TaskDefinition'\n  | 'TaskResult'\n  | 'TaskChain'\n  // LLM/Oracle Interactions\n  | 'AskOracle'\n  | 'OracleResponse'\n  // Tool Interactions\n  | 'ToolCall'\n  | 'ToolResult'\n  // Agent Interactions (sub-agents)\n  | 'AgentCall'\n  | 'AgentResult'\n  // Human Interactions\n  | 'AskHuman'\n  | 'HumanResponse'\n  | 'ExternalInput'\n  // Control Flow\n  | 'Waiting'\n  // Generic/custom (for backwards compatibility or custom visualizations)\n  | 'Custom';\n\n/**\n * Categories for grouping state types by their nature.\n * Used for color coding and layout grouping.\n */\nexport type StateCategory =\n  | 'llm' // LLM/Oracle interactions (yellow)\n  | 'tool' // Tool interactions (blue)\n  | 'agent' // Agent/Task interactions (purple)\n  | 'user' // User/Human interactions (orange)\n  | 'terminal'; // Terminal states (green/gray)\n\n/**\n * Get the category for a state type\n */\nexport function getStateCategory(type: StateType): StateCategory {\n  switch (type) {\n    // LLM/Oracle interactions (yellow)\n    case 'AskOracle':\n    case 'OracleResponse':\n      return 'llm';\n    // Tool interactions (blue)\n    case 'ToolCall':\n    case 'ToolResult':\n      return 'tool';\n    // Agent/Task interactions (purple)\n    case 'AgentCall':\n    case 'AgentResult':\n    case 'TaskDefinition':\n    case 'TaskChain':\n      return 'agent';\n    // Human interactions (orange)\n    case 'AskHuman':\n    case 'HumanResponse':\n    case 'ExternalInput':\n      return 'user';\n    // Terminal/control states (green)\n    case 'TaskResult':\n    case 'Waiting':\n      return 'terminal';\n    default:\n      return 'agent'; // Default for custom types\n  }\n}\n\n// =============================================================================\n// State Configuration\n// =============================================================================\n\n/**\n * Configuration for a single state in the visualization\n */\nexport interface StateConfig {\n  /** The type of state */\n  type: StateType;\n  /** Optional display label (defaults to type name) */\n  label?: string;\n  /** Optional metadata for custom rendering */\n  data?: Record<string, unknown>;\n  /** Override the default color for this state */\n  color?: string;\n  /** Optional border color override */\n  borderColor?: string;\n  /** Unique identifier for this state instance */\n  id?: string;\n}\n\n// =============================================================================\n// Stack Configuration\n// =============================================================================\n\n/**\n * Configuration for an interaction stack\n */\nexport interface StackConfig {\n  /** Unique identifier for this stack */\n  id: string;\n  /** Display label for the stack */\n  label?: string;\n  /** States in this stack (bottom to top) */\n  states: StateConfig[];\n  /** Branch identifier (for branched stacks) */\n  branchId?: string;\n  /** Parent stack ID (for sub-agent stacks) */\n  parentStackId?: string;\n  /** Optional metadata */\n  data?: Record<string, unknown>;\n}\n\n// =============================================================================\n// Tool Configuration\n// =============================================================================\n\n/**\n * Configuration for a tool in the visualization\n */\nexport interface ToolConfig {\n  /** Unique identifier */\n  id: string;\n  /** Display name */\n  name: string;\n  /** Optional icon (emoji or URL) */\n  icon?: string;\n  /** Override color */\n  color?: string;\n  /** Optional description */\n  description?: string;\n}\n\n// =============================================================================\n// Artifact Configuration\n// =============================================================================\n\n/**\n * Configuration for an artifact in the visualization.\n * Artifacts are external outputs created by tool calls (e.g., PDF documents, files).\n */\nexport interface ArtifactConfig {\n  /** Unique identifier */\n  id: string;\n  /** Display name */\n  name: string;\n  /** Artifact type (for icon selection) */\n  type?: 'document' | 'image' | 'data' | 'code' | 'generic';\n  /** Optional icon (emoji or URL) */\n  icon?: string;\n  /** Override color */\n  color?: string;\n  /** Optional file extension to display */\n  extension?: string;\n}\n\n// =============================================================================\n// Animation Configuration\n// =============================================================================\n\n/**\n * Easing function type\n */\nexport type EasingFunction = (t: number) => number;\n\n/**\n * Named easing presets\n */\nexport type EasingPreset =\n  | 'linear'\n  | 'easeIn'\n  | 'easeOut'\n  | 'easeInOut'\n  | 'easeInQuad'\n  | 'easeOutQuad'\n  | 'easeInOutQuad'\n  | 'easeInCubic'\n  | 'easeOutCubic'\n  | 'easeInOutCubic'\n  | 'easeInBack'\n  | 'easeOutBack'\n  | 'easeInOutBack';\n\n/**\n * Configuration for individual animations\n */\nexport interface AnimationConfig {\n  /** Duration in milliseconds (default: 500) */\n  duration?: number;\n  /** Easing function or preset name */\n  easing?: EasingFunction | EasingPreset;\n  /** Delay before starting (ms) */\n  delay?: number;\n  /** Callback when animation starts */\n  onStart?: () => void;\n  /** Callback when animation completes */\n  onComplete?: () => void;\n}\n\n// =============================================================================\n// Theme Configuration\n// =============================================================================\n\n/**\n * Color configuration for state categories\n */\nexport interface StateCategoryColors {\n  /** Background color */\n  background: string;\n  /** Border color */\n  border: string;\n  /** Text color (optional, defaults to theme text color) */\n  text?: string;\n}\n\n/**\n * Full theme configuration\n */\nexport interface ThemeConfig {\n  /** Canvas/SVG background */\n  background: string;\n  /** Colors for each state category */\n  stateColors: Record<StateCategory, StateCategoryColors>;\n  /** Default text color */\n  textColor: string;\n  /** Arrow/connector color */\n  arrowColor: string;\n  /** Stack container background */\n  stackBackground: string;\n  /** Stack border color */\n  stackBorderColor: string;\n  /** Tool box color */\n  toolColor: string;\n  /** Tool box border */\n  toolBorderColor: string;\n  /** Font family */\n  fontFamily: string;\n}\n\n// =============================================================================\n// Renderer Configuration\n// =============================================================================\n\n/**\n * Configuration for the renderer\n */\nexport interface RendererConfig {\n  /** Container element or CSS selector */\n  container: HTMLElement | string;\n  /** Canvas width (default: auto) */\n  width?: number;\n  /** Canvas height (default: auto) */\n  height?: number;\n  /** Theme preset or custom config */\n  theme?: 'light' | 'dark' | ThemeConfig;\n  /** Enable responsive sizing */\n  responsive?: boolean;\n  /** Padding inside the canvas */\n  padding?: number;\n}\n\n// =============================================================================\n// Animation Types\n// =============================================================================\n\n/**\n * Configuration for tool execution animation\n */\nexport interface ToolExecutionAnimation {\n  /** The stack receiving the states */\n  stack: StackConfig;\n  /** States to push before the tool call */\n  preStates?: StateConfig[];\n  /** The state that triggers the tool call */\n  triggerState: StateConfig;\n  /** The tool being executed */\n  tool: ToolConfig;\n  /** The result state pushed after execution */\n  resultState: StateConfig;\n  /** States to push after the tool result */\n  postStates?: StateConfig[];\n  /** Animation options */\n  options?: {\n    /** Show tool name/icon */\n    showToolDetails?: boolean;\n    /** How long tool \"runs\" in ms */\n    executionDuration?: number;\n    /** Arrow style */\n    arrowStyle?: 'straight' | 'curved' | 'stepped';\n  };\n}\n\n/**\n * Configuration for artifact creation animation.\n * Shows a tool call creating an external artifact that stays attached to the interaction.\n */\nexport interface ArtifactCreationAnimation {\n  /** The stack receiving the states */\n  stack: StackConfig;\n  /** States to push before the artifact-creating tool call */\n  preStates?: StateConfig[];\n  /** The state that creates the artifact (typically a ToolCall) */\n  creatorState: StateConfig;\n  /** The artifact being created */\n  artifact: ArtifactConfig;\n  /** The result state pushed after creation */\n  resultState: StateConfig;\n  /** States to push after the artifact is created */\n  postStates?: StateConfig[];\n  /** Animation options */\n  options?: {\n    /** Position of artifact relative to stack */\n    artifactPosition?: 'right' | 'left';\n    /** Arrow style */\n    arrowStyle?: 'straight' | 'curved' | 'stepped';\n  };\n}\n\n/**\n * Configuration for state transition diagram animation\n */\nexport interface TransitionDiagramAnimation {\n  /** Which states to show */\n  visibleStates?: StateType[] | 'all';\n  /** Starting state */\n  initialState: StateType;\n  /** Sequence of transitions to animate */\n  transitions: StateType[];\n  /** Sync with a stack view */\n  syncWithStack?: {\n    stack: StackConfig;\n    position: 'left' | 'right' | 'bottom';\n  };\n  /** Layout style */\n  layout?: 'horizontal' | 'vertical' | 'circular';\n}\n\n/**\n * Configuration for branching animation\n */\nexport interface BranchAnimation {\n  /** Original stack before branching */\n  sourceStack: StackConfig;\n  /** Point at which branching occurs (index in stack) */\n  branchPoint: number;\n  /** The branched stacks */\n  branches: Array<{\n    id: string;\n    label?: string;\n    additionalStates: StateConfig[];\n  }>;\n  /** Layout options */\n  layout?: {\n    direction: 'horizontal' | 'vertical';\n    spacing: number;\n  };\n}\n\n/**\n * Configuration for multi-stack interaction animation\n */\nexport interface MultiStackInteraction {\n  /** The initiating stack (parent agent) */\n  parentStack: StackConfig;\n  /** The receiving stack (sub-agent) */\n  childStack: StackConfig;\n  /** States to push on parent before the AgentCall */\n  parentExecution?: StateConfig[];\n  /** The call state on parent (AgentCall) */\n  callState: StateConfig;\n  /** States that execute on child */\n  childExecution: StateConfig[];\n  /** The result returned to parent */\n  resultState: StateConfig;\n  /** States to push on parent after the AgentResult */\n  parentCompletion?: StateConfig[];\n  /** Visual options */\n  options?: {\n    /** Show message content */\n    showMessageContent?: boolean;\n    /** Child stack position */\n    childPosition?: 'right' | 'below';\n    /** Animate each child step or just result */\n    animateChildSteps?: boolean;\n    /** Animate parent steps before AgentCall */\n    animateParentSteps?: boolean;\n  };\n}\n\n// =============================================================================\n// Event Types\n// =============================================================================\n\n/**\n * Events emitted by the animator\n */\nexport type AnimatorEvent =\n  | 'animationStart'\n  | 'animationComplete'\n  | 'animationStep'\n  | 'stateChange'\n  | 'branchCreated'\n  | 'stackInteraction'\n  | 'error';\n\n/**\n * Event callback signature\n */\nexport type AnimatorEventCallback = (data?: unknown) => void;\n\n// =============================================================================\n// Geometry Types\n// =============================================================================\n\n/**\n * 2D point\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * Rectangle bounds\n */\nexport interface Rect {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Arrow connection options\n */\nexport interface ArrowOptions {\n  /** Start point */\n  from: Point;\n  /** End point */\n  to: Point;\n  /** Arrow style */\n  style?: 'straight' | 'curved' | 'stepped';\n  /** Show arrowhead */\n  showHead?: boolean;\n  /** Stroke width */\n  strokeWidth?: number;\n  /** Color */\n  color?: string;\n  /** Dash pattern (for \"in progress\" arrows) */\n  dashArray?: string;\n  /** Animation style */\n  animated?: boolean;\n  /** Start hidden (opacity 0) */\n  hidden?: boolean;\n}\n\n// =============================================================================\n// Visual Element References\n// =============================================================================\n\n/**\n * Reference to a rendered element\n */\nexport interface ElementRef {\n  /** Element type */\n  type: 'state' | 'stack' | 'tool' | 'artifact' | 'arrow' | 'label';\n  /** Unique ID */\n  id: string;\n  /** DOM/SVG element */\n  element: SVGElement | HTMLElement;\n  /** Bounding box */\n  bounds: Rect;\n  /** Child element refs (e.g., state refs within a stack) */\n  childRefs?: ElementRef[];\n}\n", "/**\n * Color schemes and theme definitions\n *\n * These colors match Erik's Funhouse blog styling for state machine diagrams.\n * The design is flat with colored backgrounds and slightly darker borders.\n */\n\nimport type { ThemeConfig, StateCategory, StateConfig } from '../core/types.js';\nimport { getStateCategory } from '../core/types.js';\n\n/**\n * Light theme - matches Erik's Funhouse blog styling\n *\n * Colors from the state machine diagrams:\n * - Yellow for LLM interactions\n * - Blue for Tool interactions\n * - Pink/Salmon for User interactions\n * - Lavender for Agent interactions\n * - Green for Terminal/Finished states\n */\nexport const lightTheme: ThemeConfig = {\n  background: '#ffffff',\n\n  stateColors: {\n    // Yellow - LLM interactions (UserMessage, AssistantMessage)\n    llm: {\n      background: '#FFE082',\n      border: '#E6C200',\n      text: '#000000',\n    },\n    // Blue - Tool interactions (ToolCall, ToolResult)\n    tool: {\n      background: '#90CAF9',\n      border: '#5BA3E0',\n      text: '#000000',\n    },\n    // Lavender/Purple - Agent interactions (AgentCall, AgentResult)\n    agent: {\n      background: '#D1C4E9',\n      border: '#A094C0',\n      text: '#000000',\n    },\n    // Pink/Salmon - User interactions (UserInputRequired, UserResponse)\n    user: {\n      background: '#FFCDD2',\n      border: '#E0A0A5',\n      text: '#000000',\n    },\n    // Green - Terminal states (Finished)\n    terminal: {\n      background: '#A5D6A7',\n      border: '#70B873',\n      text: '#000000',\n    },\n  },\n\n  textColor: '#000000',\n  arrowColor: '#424242',\n  stackBackground: 'transparent',\n  stackBorderColor: 'transparent',\n  // Orange/Peach for \"execution\" boxes (Tool Execution, LLM Call, etc.)\n  toolColor: '#FFCC80',\n  toolBorderColor: '#E6A550',\n  fontFamily:\n    \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif\",\n};\n\n/**\n * Dark theme for dark mode contexts\n */\nexport const darkTheme: ThemeConfig = {\n  background: '#1a1a2e',\n\n  stateColors: {\n    // Yellow - LLM/Oracle interactions\n    llm: {\n      background: '#3d3d00',\n      border: '#fbc02d',\n      text: '#fff9c4',\n    },\n    // Blue - Tool interactions\n    tool: {\n      background: '#0d2137',\n      border: '#5dade2',\n      text: '#e3f2fd',\n    },\n    // Purple - Agent/Task interactions\n    agent: {\n      background: '#2d1f3d',\n      border: '#bb8fce',\n      text: '#f3e5f5',\n    },\n    // Orange - User/Human interactions\n    user: {\n      background: '#3d2600',\n      border: '#f5b041',\n      text: '#fff3e0',\n    },\n    // Green/Gray - Terminal states\n    terminal: {\n      background: '#1a3d1f',\n      border: '#58d68d',\n      text: '#e8f5e9',\n    },\n  },\n\n  textColor: '#eaecee',\n  arrowColor: '#5dade2',\n  stackBackground: '#2d2d44',\n  stackBorderColor: '#3d3d5c',\n  toolColor: '#1a2f3d',\n  toolBorderColor: '#5dade2',\n  fontFamily:\n    \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif\",\n};\n\n/**\n * Get theme by name or return custom theme\n */\nexport function getTheme(theme: 'light' | 'dark' | ThemeConfig): ThemeConfig {\n  if (theme === 'light') return lightTheme;\n  if (theme === 'dark') return darkTheme;\n  return theme;\n}\n\n/**\n * Get colors for a state based on its type and theme\n */\nexport function getStateColors(\n  state: StateConfig,\n  theme: ThemeConfig\n): { background: string; border: string; text: string } {\n  // Allow per-state color overrides\n  if (state.color || state.borderColor) {\n    return {\n      background: state.color || theme.stateColors.agent.background,\n      border: state.borderColor || state.color || theme.stateColors.agent.border,\n      text: theme.textColor,\n    };\n  }\n\n  const category = getStateCategory(state.type);\n  const colors = theme.stateColors[category];\n\n  return {\n    background: colors.background,\n    border: colors.border,\n    text: colors.text || theme.textColor,\n  };\n}\n\n/**\n * Lighten a hex color by a percentage\n */\nexport function lighten(hex: string, percent: number): string {\n  const num = parseInt(hex.replace('#', ''), 16);\n  const amt = Math.round(2.55 * percent);\n  const R = Math.min(255, (num >> 16) + amt);\n  const G = Math.min(255, ((num >> 8) & 0x00ff) + amt);\n  const B = Math.min(255, (num & 0x0000ff) + amt);\n  return `#${((1 << 24) | (R << 16) | (G << 8) | B).toString(16).slice(1)}`;\n}\n\n/**\n * Darken a hex color by a percentage\n */\nexport function darken(hex: string, percent: number): string {\n  const num = parseInt(hex.replace('#', ''), 16);\n  const amt = Math.round(2.55 * percent);\n  const R = Math.max(0, (num >> 16) - amt);\n  const G = Math.max(0, ((num >> 8) & 0x00ff) - amt);\n  const B = Math.max(0, (num & 0x0000ff) - amt);\n  return `#${((1 << 24) | (R << 16) | (G << 8) | B).toString(16).slice(1)}`;\n}\n\n/**\n * Add transparency to a hex color\n */\nexport function withAlpha(hex: string, alpha: number): string {\n  const num = parseInt(hex.replace('#', ''), 16);\n  const R = num >> 16;\n  const G = (num >> 8) & 0x00ff;\n  const B = num & 0x0000ff;\n  return `rgba(${R}, ${G}, ${B}, ${alpha})`;\n}\n\n/**\n * Category labels for legend/documentation\n */\nexport const categoryLabels: Record<StateCategory, string> = {\n  llm: 'LLM Interaction',\n  tool: 'Tool Execution',\n  agent: 'Agent/Task',\n  user: 'User Input',\n  terminal: 'Terminal',\n};\n", "/**\n * Layout utilities for positioning elements\n */\n\nimport type { Point, Rect, StackConfig, StateConfig } from '../core/types.js';\n\n/**\n * Default dimensions for visual elements\n *\n * These match the Erik's Funhouse blog style:\n * - Generous border radius (~14px)\n * - Clean spacing\n * - Thin arrows\n */\nexport const dimensions = {\n  state: {\n    width: 165,\n    height: 42,\n    borderRadius: 14, // Generous rounded corners like the blog\n    padding: 12,\n    fontSize: 15,\n    labelFontSize: 11,\n  },\n  stack: {\n    stateSpacing: 4, // Small gap between states\n    padding: 0, // No container padding (floating boxes)\n    labelHeight: 40, // Height for stack label area (includes spacing below label)\n    minWidth: 170,\n    borderRadius: 14,\n  },\n  tool: {\n    width: 140,\n    height: 44,\n    borderRadius: 14, // Match state border radius\n    iconSize: 18,\n  },\n  artifact: {\n    width: 100,\n    height: 70,\n    foldSize: 16, // Size of the folded corner\n    borderRadius: 4, // Smaller radius for document look\n  },\n  arrow: {\n    strokeWidth: 1.5, // Thin arrows like the blog\n    headSize: 6,\n    dashArray: '5,5',\n  },\n  spacing: {\n    stackGap: 80, // Gap between stacks\n    toolGap: 50, // Gap between stack and tool\n    branchGap: 50, // Gap between branches\n  },\n};\n\n/**\n * Calculate the height of a stack based on number of states\n */\nexport function calculateStackHeight(numStates: number): number {\n  const { stateSpacing, padding, labelHeight } = dimensions.stack;\n  const { height: stateHeight } = dimensions.state;\n\n  if (numStates === 0) {\n    return labelHeight + padding * 2 + stateHeight; // Show at least space for one state\n  }\n\n  return (\n    labelHeight +\n    padding * 2 +\n    numStates * stateHeight +\n    (numStates - 1) * stateSpacing\n  );\n}\n\n/**\n * Calculate position of a state within a stack\n * Index 0 is the bottom of the stack (first state added)\n */\nexport function getStatePositionInStack(\n  stackX: number,\n  stackY: number,\n  stackWidth: number,\n  totalStates: number,\n  stateIndex: number\n): Point {\n  const { stateSpacing, padding, labelHeight } = dimensions.stack;\n  const { height: stateHeight, width: stateWidth } = dimensions.state;\n\n  // Center state horizontally in stack\n  const x = stackX + (stackWidth - stateWidth) / 2;\n\n  // Position from top, but logically index from bottom\n  // So index 0 appears at the bottom, index n-1 at the top\n  const reversedIndex = totalStates - 1 - stateIndex;\n  const y =\n    stackY + labelHeight + padding + reversedIndex * (stateHeight + stateSpacing);\n\n  return { x, y };\n}\n\n/**\n * Calculate the bounds of a stack\n */\nexport function getStackBounds(\n  stack: StackConfig,\n  position: Point\n): Rect {\n  const height = calculateStackHeight(stack.states.length);\n  const width = Math.max(\n    dimensions.stack.minWidth,\n    dimensions.state.width + dimensions.stack.padding * 2\n  );\n\n  return {\n    x: position.x,\n    y: position.y,\n    width,\n    height,\n  };\n}\n\n/**\n * Calculate center point of a rectangle\n */\nexport function getRectCenter(rect: Rect): Point {\n  return {\n    x: rect.x + rect.width / 2,\n    y: rect.y + rect.height / 2,\n  };\n}\n\n/**\n * Calculate connection points for arrows between elements\n */\nexport function getConnectionPoints(\n  from: Rect,\n  to: Rect,\n  fromSide: 'top' | 'bottom' | 'left' | 'right' = 'right',\n  toSide: 'top' | 'bottom' | 'left' | 'right' = 'left'\n): { from: Point; to: Point } {\n  const getPoint = (rect: Rect, side: string): Point => {\n    switch (side) {\n      case 'top':\n        return { x: rect.x + rect.width / 2, y: rect.y };\n      case 'bottom':\n        return { x: rect.x + rect.width / 2, y: rect.y + rect.height };\n      case 'left':\n        return { x: rect.x, y: rect.y + rect.height / 2 };\n      case 'right':\n        return { x: rect.x + rect.width, y: rect.y + rect.height / 2 };\n      default:\n        return getRectCenter(rect);\n    }\n  };\n\n  return {\n    from: getPoint(from, fromSide),\n    to: getPoint(to, toSide),\n  };\n}\n\n/**\n * Generate SVG path for a curved arrow\n */\nexport function getCurvedArrowPath(from: Point, to: Point): string {\n  const midX = (from.x + to.x) / 2;\n  const midY = (from.y + to.y) / 2;\n\n  // Calculate control points for a smooth curve\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n\n  // Offset perpendicular to the line for curve\n  const curveOffset = Math.min(Math.abs(dx), Math.abs(dy)) * 0.3;\n\n  // Simple quadratic curve\n  const controlX = midX;\n  const controlY = midY - curveOffset;\n\n  return `M ${from.x} ${from.y} Q ${controlX} ${controlY} ${to.x} ${to.y}`;\n}\n\n/**\n * Generate SVG path for a stepped arrow (right-angle turns)\n */\nexport function getSteppedArrowPath(from: Point, to: Point): string {\n  const midX = (from.x + to.x) / 2;\n\n  return `M ${from.x} ${from.y} L ${midX} ${from.y} L ${midX} ${to.y} L ${to.x} ${to.y}`;\n}\n\n/**\n * Generate SVG path for a straight arrow\n */\nexport function getStraightArrowPath(from: Point, to: Point): string {\n  return `M ${from.x} ${from.y} L ${to.x} ${to.y}`;\n}\n\n/**\n * Calculate arrowhead points\n */\nexport function getArrowheadPoints(\n  to: Point,\n  from: Point,\n  size: number = dimensions.arrow.headSize\n): string {\n  const angle = Math.atan2(to.y - from.y, to.x - from.x);\n  const angle1 = angle + Math.PI * 0.8;\n  const angle2 = angle - Math.PI * 0.8;\n\n  const x1 = to.x + size * Math.cos(angle1);\n  const y1 = to.y + size * Math.sin(angle1);\n  const x2 = to.x + size * Math.cos(angle2);\n  const y2 = to.y + size * Math.sin(angle2);\n\n  return `${to.x},${to.y} ${x1},${y1} ${x2},${y2}`;\n}\n\n/**\n * Layout multiple stacks horizontally\n */\nexport function layoutStacksHorizontally(\n  stacks: StackConfig[],\n  startX: number,\n  startY: number\n): Map<string, Point> {\n  const positions = new Map<string, Point>();\n  let currentX = startX;\n\n  for (const stack of stacks) {\n    positions.set(stack.id, { x: currentX, y: startY });\n    const bounds = getStackBounds(stack, { x: currentX, y: startY });\n    currentX += bounds.width + dimensions.spacing.stackGap;\n  }\n\n  return positions;\n}\n\n/**\n * Layout branches from a source stack\n */\nexport function layoutBranches(\n  sourceStack: StackConfig,\n  branches: Array<{ id: string; states: StateConfig[] }>,\n  sourcePosition: Point,\n  branchPoint: number\n): Map<string, Point> {\n  const positions = new Map<string, Point>();\n  const sourceBounds = getStackBounds(sourceStack, sourcePosition);\n\n  // Calculate Y position for branch point\n  const branchY =\n    sourcePosition.y +\n    dimensions.stack.labelHeight +\n    dimensions.stack.padding +\n    (sourceStack.states.length - branchPoint) *\n      (dimensions.state.height + dimensions.stack.stateSpacing);\n\n  // Layout branches horizontally, centered below branch point\n  const totalWidth =\n    branches.length * dimensions.stack.minWidth +\n    (branches.length - 1) * dimensions.spacing.branchGap;\n\n  let startX = sourcePosition.x + sourceBounds.width / 2 - totalWidth / 2;\n  const branchStartY = branchY + dimensions.spacing.branchGap;\n\n  for (const branch of branches) {\n    positions.set(branch.id, { x: startX, y: branchStartY });\n    startX += dimensions.stack.minWidth + dimensions.spacing.branchGap;\n  }\n\n  return positions;\n}\n", "/**\n * SVG-based renderer for state machine visualizations\n *\n * Uses SVG for crisp, scalable graphics with smooth CSS animations.\n */\n\nimport type {\n  RendererConfig,\n  ThemeConfig,\n  StateConfig,\n  StackConfig,\n  ToolConfig,\n  ArtifactConfig,\n  Point,\n  Rect,\n  ArrowOptions,\n  ElementRef,\n} from '../core/types.js';\nimport { getTheme, getStateColors } from '../utils/colors.js';\nimport {\n  dimensions,\n  getStatePositionInStack,\n  calculateStackHeight,\n  getCurvedArrowPath,\n  getStraightArrowPath,\n  getSteppedArrowPath,\n} from '../utils/layout.js';\n\n/**\n * SVG namespace\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Create an SVG element with attributes\n */\nfunction createSVGElement<K extends keyof SVGElementTagNameMap>(\n  tagName: K,\n  attributes: Record<string, string | number> = {}\n): SVGElementTagNameMap[K] {\n  const element = document.createElementNS(SVG_NS, tagName);\n  for (const [key, value] of Object.entries(attributes)) {\n    element.setAttribute(key, String(value));\n  }\n  return element;\n}\n\n/**\n * Generate a unique ID\n */\nlet idCounter = 0;\nfunction generateId(prefix: string): string {\n  return `${prefix}-${++idCounter}`;\n}\n\n/**\n * SVG Renderer class\n */\nexport class SVGRenderer {\n  private container: HTMLElement;\n  private svg: SVGSVGElement;\n  private defs: SVGDefsElement;\n  private mainGroup: SVGGElement;\n  private theme: ThemeConfig;\n  private width: number;\n  private height: number;\n  private padding: number;\n  private elements: Map<string, ElementRef> = new Map();\n  private resizeObserver: ResizeObserver | null = null;\n\n  // Pan and zoom state\n  private panX: number = 0;\n  private panY: number = 0;\n  private zoom: number = 1;\n  private isPanning: boolean = false;\n  private lastMouseX: number = 0;\n  private lastMouseY: number = 0;\n  private minZoom: number = 0.25;\n  private maxZoom: number = 4;\n\n  // Tooltip elements\n  private tooltipGroup: SVGGElement | null = null;\n  private tooltipVisible: boolean = false;\n\n  constructor(config: RendererConfig) {\n    // Resolve container\n    if (typeof config.container === 'string') {\n      const el = document.querySelector(config.container);\n      if (!el) {\n        throw new Error(`Container not found: ${config.container}`);\n      }\n      this.container = el as HTMLElement;\n    } else {\n      this.container = config.container;\n    }\n\n    // Initialize theme\n    this.theme = getTheme(config.theme || 'light');\n    this.padding = config.padding ?? 20;\n\n    // Get dimensions\n    this.width = config.width ?? (this.container.clientWidth || 800);\n    this.height = config.height ?? (this.container.clientHeight || 600);\n\n    // Create SVG\n    this.svg = createSVGElement('svg', {\n      width: this.width,\n      height: this.height,\n      viewBox: `0 0 ${this.width} ${this.height}`,\n    });\n    this.svg.style.fontFamily = this.theme.fontFamily;\n    this.svg.style.display = 'block';\n\n    // Create defs for gradients, filters, etc.\n    this.defs = createSVGElement('defs');\n    this.svg.appendChild(this.defs);\n    this.addFiltersAndGradients();\n\n    // Create main group for transforms\n    this.mainGroup = createSVGElement('g', {\n      transform: `translate(${this.padding}, ${this.padding})`,\n    });\n    this.svg.appendChild(this.mainGroup);\n\n    // Add background\n    this.drawBackground();\n\n    // Append to container\n    this.container.appendChild(this.svg);\n\n    // Setup responsive resizing\n    if (config.responsive) {\n      this.setupResponsive();\n    }\n\n    // Setup pan and zoom handlers\n    this.setupPanZoom();\n\n    // Create tooltip (added last so it's on top)\n    this.createTooltip();\n  }\n\n  /**\n   * Setup pan and zoom event handlers\n   */\n  private setupPanZoom(): void {\n    // Change cursor to indicate draggable\n    this.svg.style.cursor = 'grab';\n\n    // Mouse down - start panning\n    this.svg.addEventListener('mousedown', (e: MouseEvent) => {\n      // Only pan with left mouse button\n      if (e.button !== 0) return;\n\n      this.isPanning = true;\n      this.lastMouseX = e.clientX;\n      this.lastMouseY = e.clientY;\n      this.svg.style.cursor = 'grabbing';\n      e.preventDefault();\n    });\n\n    // Mouse move - pan if dragging\n    this.svg.addEventListener('mousemove', (e: MouseEvent) => {\n      if (!this.isPanning) return;\n\n      const dx = e.clientX - this.lastMouseX;\n      const dy = e.clientY - this.lastMouseY;\n\n      this.panX += dx / this.zoom;\n      this.panY += dy / this.zoom;\n\n      this.lastMouseX = e.clientX;\n      this.lastMouseY = e.clientY;\n\n      this.updateTransform();\n    });\n\n    // Mouse up - stop panning\n    this.svg.addEventListener('mouseup', () => {\n      this.isPanning = false;\n      this.svg.style.cursor = 'grab';\n    });\n\n    // Mouse leave - stop panning\n    this.svg.addEventListener('mouseleave', () => {\n      this.isPanning = false;\n      this.svg.style.cursor = 'grab';\n    });\n\n    // Wheel - zoom\n    this.svg.addEventListener('wheel', (e: WheelEvent) => {\n      e.preventDefault();\n\n      // Get mouse position relative to SVG\n      const rect = this.svg.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      // Calculate zoom factor\n      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;\n      const newZoom = Math.max(\n        this.minZoom,\n        Math.min(this.maxZoom, this.zoom * zoomFactor)\n      );\n\n      // Adjust pan to zoom towards mouse position\n      if (newZoom !== this.zoom) {\n        const zoomRatio = newZoom / this.zoom;\n        this.panX -= (mouseX / this.zoom) * (zoomRatio - 1);\n        this.panY -= (mouseY / this.zoom) * (zoomRatio - 1);\n        this.zoom = newZoom;\n        this.updateTransform();\n      }\n    });\n  }\n\n  /**\n   * Update the main group transform based on pan/zoom state\n   */\n  private updateTransform(): void {\n    this.mainGroup.setAttribute(\n      'transform',\n      `translate(${this.panX + this.padding}, ${this.panY + this.padding}) scale(${this.zoom})`\n    );\n  }\n\n  /**\n   * Reset pan and zoom to default\n   */\n  resetView(): void {\n    this.panX = 0;\n    this.panY = 0;\n    this.zoom = 1;\n    this.updateTransform();\n  }\n\n  /**\n   * Set zoom level programmatically\n   */\n  setZoom(level: number): void {\n    this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, level));\n    this.updateTransform();\n  }\n\n  /**\n   * Get current zoom level\n   */\n  getZoom(): number {\n    return this.zoom;\n  }\n\n  /**\n   * Create tooltip element\n   */\n  private createTooltip(): void {\n    this.tooltipGroup = createSVGElement('g', {\n      class: 'tooltip',\n      style: 'pointer-events: none; opacity: 0; transition: opacity 0.15s ease-out;',\n    });\n\n    // Tooltip background\n    const bg = createSVGElement('rect', {\n      class: 'tooltip-bg',\n      rx: 6,\n      ry: 6,\n      fill: 'rgba(45, 55, 72, 0.95)',\n      stroke: 'rgba(255, 255, 255, 0.1)',\n      'stroke-width': 1,\n    });\n    this.tooltipGroup.appendChild(bg);\n\n    // Tooltip text container\n    const textGroup = createSVGElement('g', {\n      class: 'tooltip-text',\n    });\n    this.tooltipGroup.appendChild(textGroup);\n\n    this.svg.appendChild(this.tooltipGroup);\n  }\n\n  /**\n   * Show tooltip with state information\n   */\n  showTooltip(\n    state: StateConfig,\n    screenX: number,\n    screenY: number\n  ): void {\n    if (!this.tooltipGroup) return;\n\n    const textGroup = this.tooltipGroup.querySelector('.tooltip-text') as SVGGElement;\n    const bg = this.tooltipGroup.querySelector('.tooltip-bg') as SVGRectElement;\n\n    // Clear previous text\n    while (textGroup.firstChild) {\n      textGroup.removeChild(textGroup.firstChild);\n    }\n\n    const padding = 12;\n    const lineHeight = 18;\n    let currentY = padding + 12;\n    let maxWidth = 0;\n\n    // State type (bold, larger)\n    const typeText = createSVGElement('text', {\n      x: padding,\n      y: currentY,\n      'font-size': 13,\n      'font-weight': '600',\n      fill: '#fff',\n    });\n    typeText.textContent = state.type;\n    textGroup.appendChild(typeText);\n    maxWidth = Math.max(maxWidth, state.type.length * 8);\n    currentY += lineHeight;\n\n    // Label (if exists and different from type)\n    if (state.label) {\n      const labelText = createSVGElement('text', {\n        x: padding,\n        y: currentY,\n        'font-size': 11,\n        fill: 'rgba(255, 255, 255, 0.8)',\n      });\n      labelText.textContent = state.label;\n      textGroup.appendChild(labelText);\n      maxWidth = Math.max(maxWidth, state.label.length * 6);\n      currentY += lineHeight;\n    }\n\n    // Additional data if present\n    if (state.data) {\n      currentY += 4; // Small gap\n      const dataEntries = Object.entries(state.data).slice(0, 3); // Limit to 3 entries\n      for (const [key, value] of dataEntries) {\n        const dataText = createSVGElement('text', {\n          x: padding,\n          y: currentY,\n          'font-size': 10,\n          fill: 'rgba(255, 255, 255, 0.6)',\n        });\n        const valueStr = String(value).substring(0, 30);\n        dataText.textContent = `${key}: ${valueStr}`;\n        textGroup.appendChild(dataText);\n        maxWidth = Math.max(maxWidth, (key.length + valueStr.length + 2) * 5.5);\n        currentY += lineHeight - 4;\n      }\n    }\n\n    // Size background\n    const tooltipWidth = Math.max(120, maxWidth + padding * 2);\n    const tooltipHeight = currentY + padding - 6;\n    bg.setAttribute('width', String(tooltipWidth));\n    bg.setAttribute('height', String(tooltipHeight));\n\n    // Position tooltip (offset from cursor, ensure visible)\n    const svgRect = this.svg.getBoundingClientRect();\n    let tooltipX = screenX - svgRect.left + 15;\n    let tooltipY = screenY - svgRect.top - tooltipHeight / 2;\n\n    // Keep within bounds\n    if (tooltipX + tooltipWidth > this.width - 10) {\n      tooltipX = screenX - svgRect.left - tooltipWidth - 15;\n    }\n    if (tooltipY < 10) {\n      tooltipY = 10;\n    }\n    if (tooltipY + tooltipHeight > this.height - 10) {\n      tooltipY = this.height - tooltipHeight - 10;\n    }\n\n    this.tooltipGroup.setAttribute('transform', `translate(${tooltipX}, ${tooltipY})`);\n    this.tooltipGroup.style.opacity = '1';\n    this.tooltipVisible = true;\n  }\n\n  /**\n   * Hide tooltip\n   */\n  hideTooltip(): void {\n    if (this.tooltipGroup && this.tooltipVisible) {\n      this.tooltipGroup.style.opacity = '0';\n      this.tooltipVisible = false;\n    }\n  }\n\n  /**\n   * Pan to center on a specific point\n   */\n  panTo(x: number, y: number): void {\n    this.panX = this.width / 2 / this.zoom - x;\n    this.panY = this.height / 2 / this.zoom - y;\n    this.updateTransform();\n  }\n\n  /**\n   * Add reusable SVG definitions\n   */\n  private addFiltersAndGradients(): void {\n    // Drop shadow filter\n    const dropShadow = createSVGElement('filter', {\n      id: 'drop-shadow',\n      x: '-20%',\n      y: '-20%',\n      width: '140%',\n      height: '140%',\n    });\n\n    const feGaussianBlur = createSVGElement('feGaussianBlur', {\n      in: 'SourceAlpha',\n      stdDeviation: '2',\n      result: 'blur',\n    });\n\n    const feOffset = createSVGElement('feOffset', {\n      in: 'blur',\n      dx: '0',\n      dy: '1',\n      result: 'offsetBlur',\n    });\n\n    const feFlood = createSVGElement('feFlood', {\n      'flood-color': 'rgba(0,0,0,0.15)',\n      result: 'color',\n    });\n\n    const feComposite = createSVGElement('feComposite', {\n      in: 'color',\n      in2: 'offsetBlur',\n      operator: 'in',\n      result: 'shadow',\n    });\n\n    const feMerge = createSVGElement('feMerge');\n    const feMergeNode1 = createSVGElement('feMergeNode', { in: 'shadow' });\n    const feMergeNode2 = createSVGElement('feMergeNode', { in: 'SourceGraphic' });\n    feMerge.appendChild(feMergeNode1);\n    feMerge.appendChild(feMergeNode2);\n\n    dropShadow.appendChild(feGaussianBlur);\n    dropShadow.appendChild(feOffset);\n    dropShadow.appendChild(feFlood);\n    dropShadow.appendChild(feComposite);\n    dropShadow.appendChild(feMerge);\n    this.defs.appendChild(dropShadow);\n\n    // Glow filter for highlights\n    const glow = createSVGElement('filter', {\n      id: 'glow',\n      x: '-50%',\n      y: '-50%',\n      width: '200%',\n      height: '200%',\n    });\n\n    const feGlow = createSVGElement('feGaussianBlur', {\n      stdDeviation: '3',\n      result: 'coloredBlur',\n    });\n\n    const feMergeGlow = createSVGElement('feMerge');\n    const feMergeGlowNode1 = createSVGElement('feMergeNode', { in: 'coloredBlur' });\n    const feMergeGlowNode2 = createSVGElement('feMergeNode', { in: 'SourceGraphic' });\n    feMergeGlow.appendChild(feMergeGlowNode1);\n    feMergeGlow.appendChild(feMergeGlowNode2);\n\n    glow.appendChild(feGlow);\n    glow.appendChild(feMergeGlow);\n    this.defs.appendChild(glow);\n\n    // Arrow marker\n    const arrowMarker = createSVGElement('marker', {\n      id: 'arrowhead',\n      markerWidth: '10',\n      markerHeight: '7',\n      refX: '9',\n      refY: '3.5',\n      orient: 'auto',\n      markerUnits: 'strokeWidth',\n    });\n\n    const arrowPath = createSVGElement('polygon', {\n      points: '0 0, 10 3.5, 0 7',\n      fill: this.theme.arrowColor,\n    });\n    arrowMarker.appendChild(arrowPath);\n    this.defs.appendChild(arrowMarker);\n  }\n\n  /**\n   * Draw background\n   */\n  private drawBackground(): void {\n    const bg = createSVGElement('rect', {\n      x: -this.padding,\n      y: -this.padding,\n      width: this.width,\n      height: this.height,\n      fill: this.theme.background,\n    });\n    this.mainGroup.insertBefore(bg, this.mainGroup.firstChild);\n  }\n\n  /**\n   * Setup responsive behavior\n   */\n  private setupResponsive(): void {\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect;\n        if (width > 0 && height > 0) {\n          this.resize(width, height);\n        }\n      }\n    });\n    this.resizeObserver.observe(this.container);\n  }\n\n  /**\n   * Clear all rendered elements\n   */\n  clear(): void {\n    while (this.mainGroup.children.length > 1) {\n      // Keep background\n      this.mainGroup.removeChild(this.mainGroup.lastChild!);\n    }\n    this.elements.clear();\n  }\n\n  /**\n   * Resize the canvas\n   */\n  resize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.svg.setAttribute('width', String(width));\n    this.svg.setAttribute('height', String(height));\n    this.svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n  }\n\n  /**\n   * Get the SVG element\n   */\n  getElement(): SVGSVGElement {\n    return this.svg;\n  }\n\n  /**\n   * Get the theme\n   */\n  getTheme(): ThemeConfig {\n    return this.theme;\n  }\n\n  /**\n   * Get available drawing area\n   */\n  getDrawingArea(): Rect {\n    return {\n      x: 0,\n      y: 0,\n      width: this.width - this.padding * 2,\n      height: this.height - this.padding * 2,\n    };\n  }\n\n  /**\n   * Draw a state box\n   */\n  drawState(state: StateConfig, x: number, y: number): ElementRef {\n    const id = state.id || generateId('state');\n    const colors = getStateColors(state, this.theme);\n    const { width, height, borderRadius, padding, fontSize, labelFontSize } =\n      dimensions.state;\n\n    // Create group for the state\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'state-box',\n    });\n\n    // Background rectangle (flat design, no shadow)\n    const rect = createSVGElement('rect', {\n      x: 0,\n      y: 0,\n      width,\n      height,\n      rx: borderRadius,\n      ry: borderRadius,\n      fill: colors.background,\n      stroke: colors.border,\n      'stroke-width': 1.5,\n    });\n    group.appendChild(rect);\n\n    // State type label (centered like the blog)\n    const typeLabel = createSVGElement('text', {\n      x: width / 2,\n      y: height / 2 - (state.label ? 4 : 0),\n      'font-size': fontSize,\n      'font-weight': '500',\n      fill: colors.text,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    typeLabel.textContent = state.type;\n    group.appendChild(typeLabel);\n\n    // Optional detail label (centered)\n    if (state.label) {\n      const detailLabel = createSVGElement('text', {\n        x: width / 2,\n        y: height / 2 + 10,\n        'font-size': labelFontSize,\n        fill: colors.text,\n        opacity: 0.7,\n        'text-anchor': 'middle',\n        'dominant-baseline': 'middle',\n      });\n      // Truncate long labels\n      const maxLen = Math.floor((width - padding * 2) / 6);\n      detailLabel.textContent =\n        state.label.length > maxLen\n          ? state.label.substring(0, maxLen - 2) + '...'\n          : state.label;\n      group.appendChild(detailLabel);\n    }\n\n    this.mainGroup.appendChild(group);\n\n    // Add hover effect and tooltip\n    group.style.cursor = 'pointer';\n    (group as SVGGElement).addEventListener('mouseenter', (e: MouseEvent) => {\n      rect.setAttribute('stroke-width', '2.5');\n      rect.style.filter = 'brightness(1.05)';\n      this.showTooltip(state, e.clientX, e.clientY);\n    });\n    (group as SVGGElement).addEventListener('mousemove', (e: MouseEvent) => {\n      if (this.tooltipVisible) {\n        this.showTooltip(state, e.clientX, e.clientY);\n      }\n    });\n    (group as SVGGElement).addEventListener('mouseleave', () => {\n      rect.setAttribute('stroke-width', '1.5');\n      rect.style.filter = '';\n      this.hideTooltip();\n    });\n\n    const ref: ElementRef = {\n      type: 'state',\n      id,\n      element: group,\n      bounds: { x, y, width, height },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw a stack container with states\n   */\n  drawStack(stack: StackConfig, x: number, y: number): ElementRef {\n    const id = stack.id || generateId('stack');\n    const { padding: stackPadding, borderRadius, minWidth } =\n      dimensions.stack;\n    const { width: stateWidth } = dimensions.state;\n\n    const stackWidth = Math.max(minWidth, stateWidth + stackPadding * 2);\n    const stackHeight = calculateStackHeight(stack.states.length);\n\n    // Create group for the stack\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'stack-container',\n    });\n\n    // Stack background\n    const bg = createSVGElement('rect', {\n      x: 0,\n      y: 0,\n      width: stackWidth,\n      height: stackHeight,\n      rx: borderRadius,\n      ry: borderRadius,\n      fill: this.theme.stackBackground,\n      stroke: this.theme.stackBorderColor,\n      'stroke-width': 1,\n    });\n    group.appendChild(bg);\n\n    // Stack label\n    if (stack.label) {\n      const label = createSVGElement('text', {\n        x: stackWidth / 2,\n        y: 18,\n        'font-size': 14,\n        'font-weight': '600',\n        fill: this.theme.textColor,\n        'text-anchor': 'middle',\n        'dominant-baseline': 'middle',\n      });\n      label.textContent = stack.label;\n      group.appendChild(label);\n\n      // Separator line\n      const sep = createSVGElement('line', {\n        x1: stackPadding + 8,\n        y1: 32,\n        x2: stackWidth - stackPadding - 8,\n        y2: 32,\n        stroke: this.theme.stackBorderColor,\n        'stroke-width': 1,\n      });\n      group.appendChild(sep);\n    }\n\n    this.mainGroup.appendChild(group);\n\n    // Draw states within stack\n    const stateRefs: ElementRef[] = [];\n    for (let i = 0; i < stack.states.length; i++) {\n      const statePos = getStatePositionInStack(\n        x,\n        y,\n        stackWidth,\n        stack.states.length,\n        i\n      );\n      const stateRef = this.drawState(stack.states[i], statePos.x, statePos.y);\n      stateRefs.push(stateRef);\n    }\n\n    // Draw arrows between states\n    for (let i = 0; i < stateRefs.length - 1; i++) {\n      const from = stateRefs[i];\n      const to = stateRefs[i + 1];\n      this.drawStackArrow(\n        { x: from.bounds.x + from.bounds.width / 2, y: from.bounds.y },\n        { x: to.bounds.x + to.bounds.width / 2, y: to.bounds.y + to.bounds.height }\n      );\n    }\n\n    const ref: ElementRef = {\n      type: 'stack',\n      id,\n      element: group,\n      bounds: { x, y, width: stackWidth, height: stackHeight },\n      childRefs: stateRefs,\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw a small arrow between stack states\n   */\n  private drawStackArrow(from: Point, to: Point): void {\n    const arrow = createSVGElement('text', {\n      x: from.x,\n      y: (from.y + to.y) / 2 + 2,\n      'font-size': 10,\n      fill: this.theme.arrowColor,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    arrow.textContent = '\u2193';\n    this.mainGroup.appendChild(arrow);\n  }\n\n  /**\n   * Draw a tool box\n   */\n  drawTool(tool: ToolConfig, x: number, y: number, hidden: boolean = false): ElementRef {\n    const id = tool.id || generateId('tool');\n    const { width, height, borderRadius } = dimensions.tool;\n\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'tool-box',\n      style: hidden ? 'opacity: 0;' : '',\n    });\n\n    // Background (flat design, no shadow)\n    const rect = createSVGElement('rect', {\n      x: 0,\n      y: 0,\n      width,\n      height,\n      rx: borderRadius,\n      ry: borderRadius,\n      fill: tool.color || this.theme.toolColor,\n      stroke: this.theme.toolBorderColor,\n      'stroke-width': 1.5,\n    });\n    group.appendChild(rect);\n\n    // Tool name (centered, with optional icon)\n    const displayText = tool.icon ? `${tool.icon} ${tool.name}` : tool.name;\n    const name = createSVGElement('text', {\n      x: width / 2,\n      y: height / 2,\n      'font-size': 14,\n      'font-weight': '500',\n      fill: this.theme.textColor,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    name.textContent = displayText;\n    group.appendChild(name);\n\n    this.mainGroup.appendChild(group);\n\n    const ref: ElementRef = {\n      type: 'tool',\n      id,\n      element: group,\n      bounds: { x, y, width, height },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw an artifact (document with folded corner)\n   */\n  drawArtifact(artifact: ArtifactConfig, x: number, y: number, hidden: boolean = false): ElementRef {\n    const id = artifact.id || generateId('artifact');\n    const { width, height, foldSize, borderRadius } = dimensions.artifact;\n\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'artifact',\n      style: hidden ? 'opacity: 0;' : '',\n    });\n\n    // Document shape with folded corner (top-right)\n    // Path: start top-left, go right (minus fold), diagonal fold, down, left, up\n    const docPath = `\n      M ${borderRadius} 0\n      L ${width - foldSize} 0\n      L ${width} ${foldSize}\n      L ${width} ${height - borderRadius}\n      Q ${width} ${height} ${width - borderRadius} ${height}\n      L ${borderRadius} ${height}\n      Q 0 ${height} 0 ${height - borderRadius}\n      L 0 ${borderRadius}\n      Q 0 0 ${borderRadius} 0\n      Z\n    `;\n\n    const doc = createSVGElement('path', {\n      d: docPath,\n      fill: artifact.color || '#e8f5e9',\n      stroke: '#4caf50',\n      'stroke-width': 1.5,\n    });\n    group.appendChild(doc);\n\n    // Folded corner triangle\n    const foldPath = `\n      M ${width - foldSize} 0\n      L ${width - foldSize} ${foldSize}\n      L ${width} ${foldSize}\n      Z\n    `;\n    const fold = createSVGElement('path', {\n      d: foldPath,\n      fill: '#c8e6c9',\n      stroke: '#4caf50',\n      'stroke-width': 1,\n    });\n    group.appendChild(fold);\n\n    // Icon based on artifact type\n    let icon = artifact.icon;\n    if (!icon) {\n      switch (artifact.type) {\n        case 'document':\n          icon = '\\u{1F4C4}'; // Page facing up\n          break;\n        case 'image':\n          icon = '\\u{1F5BC}'; // Framed picture\n          break;\n        case 'data':\n          icon = '\\u{1F4CA}'; // Bar chart\n          break;\n        case 'code':\n          icon = '\\u{1F4BB}'; // Laptop\n          break;\n        default:\n          icon = '\\u{1F4C1}'; // File folder\n      }\n    }\n\n    // Icon\n    const iconText = createSVGElement('text', {\n      x: width / 2,\n      y: height / 2 - 6,\n      'font-size': 20,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    iconText.textContent = icon;\n    group.appendChild(iconText);\n\n    // Artifact name\n    const name = createSVGElement('text', {\n      x: width / 2,\n      y: height - 12,\n      'font-size': 10,\n      'font-weight': '500',\n      fill: '#2e7d32',\n      'text-anchor': 'middle',\n    });\n    // Truncate name if too long\n    const displayName = artifact.name.length > 12\n      ? artifact.name.substring(0, 10) + '...'\n      : artifact.name;\n    name.textContent = artifact.extension\n      ? `${displayName}.${artifact.extension}`\n      : displayName;\n    group.appendChild(name);\n\n    this.mainGroup.appendChild(group);\n\n    const ref: ElementRef = {\n      type: 'artifact',\n      id,\n      element: group,\n      bounds: { x, y, width, height },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw an arrow/connection between two points\n   */\n  drawArrow(options: ArrowOptions): ElementRef {\n    const id = generateId('arrow');\n    const { from, to, style = 'curved', strokeWidth = 2, color, dashArray, animated, hidden } = options;\n\n    const group = createSVGElement('g', {\n      id,\n      class: 'arrow',\n      style: hidden ? 'opacity: 0;' : '',\n    });\n\n    // Calculate path based on style\n    let pathD: string;\n    switch (style) {\n      case 'straight':\n        pathD = getStraightArrowPath(from, to);\n        break;\n      case 'stepped':\n        pathD = getSteppedArrowPath(from, to);\n        break;\n      case 'curved':\n      default:\n        pathD = getCurvedArrowPath(from, to);\n    }\n\n    // Draw path\n    const path = createSVGElement('path', {\n      d: pathD,\n      fill: 'none',\n      stroke: color || this.theme.arrowColor,\n      'stroke-width': strokeWidth,\n      'stroke-linecap': 'round',\n      'marker-end': options.showHead !== false ? 'url(#arrowhead)' : '',\n    });\n\n    if (dashArray) {\n      path.setAttribute('stroke-dasharray', dashArray);\n    }\n\n    if (animated) {\n      path.setAttribute('stroke-dasharray', '8 4');\n      path.style.animation = 'dash 0.5s linear infinite';\n    }\n\n    group.appendChild(path);\n    this.mainGroup.appendChild(group);\n\n    // Calculate bounding box\n    const minX = Math.min(from.x, to.x);\n    const minY = Math.min(from.y, to.y);\n    const maxX = Math.max(from.x, to.x);\n    const maxY = Math.max(from.y, to.y);\n\n    const ref: ElementRef = {\n      type: 'arrow',\n      id,\n      element: group,\n      bounds: { x: minX, y: minY, width: maxX - minX, height: maxY - minY },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Update an arrow's path to new endpoints (with animation)\n   */\n  async updateArrowPath(\n    arrowRef: ElementRef,\n    from: Point,\n    to: Point,\n    style: 'straight' | 'curved' | 'stepped' = 'curved',\n    duration: number = 300\n  ): Promise<void> {\n    const group = arrowRef.element as SVGGElement;\n    const path = group.querySelector('path');\n    if (!path) return;\n\n    // Calculate new path\n    let pathD: string;\n    switch (style) {\n      case 'straight':\n        pathD = getStraightArrowPath(from, to);\n        break;\n      case 'stepped':\n        pathD = getSteppedArrowPath(from, to);\n        break;\n      case 'curved':\n      default:\n        pathD = getCurvedArrowPath(from, to);\n    }\n\n    // Animate the path change using CSS transition\n    path.style.transition = `d ${duration}ms ease-in-out`;\n    path.setAttribute('d', pathD);\n\n    // Update bounds\n    const minX = Math.min(from.x, to.x);\n    const minY = Math.min(from.y, to.y);\n    const maxX = Math.max(from.x, to.x);\n    const maxY = Math.max(from.y, to.y);\n    arrowRef.bounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\n\n    await new Promise((resolve) => setTimeout(resolve, duration));\n  }\n\n  /**\n   * Draw a text label\n   */\n  drawLabel(\n    text: string,\n    x: number,\n    y: number,\n    options: {\n      fontSize?: number;\n      fontWeight?: string;\n      color?: string;\n      anchor?: 'start' | 'middle' | 'end';\n    } = {}\n  ): ElementRef {\n    const id = generateId('label');\n    const { fontSize = 12, fontWeight = 'normal', color, anchor = 'start' } = options;\n\n    const label = createSVGElement('text', {\n      id,\n      x,\n      y,\n      'font-size': fontSize,\n      'font-weight': fontWeight,\n      fill: color || this.theme.textColor,\n      'text-anchor': anchor,\n      'dominant-baseline': 'middle',\n    });\n    label.textContent = text;\n\n    this.mainGroup.appendChild(label);\n\n    const ref: ElementRef = {\n      type: 'label',\n      id,\n      element: label,\n      bounds: { x, y: y - fontSize / 2, width: text.length * fontSize * 0.6, height: fontSize },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Get an element reference by ID\n   */\n  getElementRef(id: string): ElementRef | undefined {\n    return this.elements.get(id);\n  }\n\n  /**\n   * Remove an element\n   */\n  removeElement(id: string): void {\n    const ref = this.elements.get(id);\n    if (ref) {\n      ref.element.remove();\n      this.elements.delete(id);\n    }\n  }\n\n  /**\n   * Animate an element's properties\n   */\n  async animate(\n    element: SVGElement,\n    props: Record<string, string | number>,\n    duration: number = 500\n  ): Promise<void> {\n    return new Promise((resolve) => {\n      // Use CSS transitions for smooth animation\n      element.style.transition = `all ${duration}ms ease-in-out`;\n\n      // Apply transform properties\n      if ('x' in props || 'y' in props) {\n        const currentTransform = element.getAttribute('transform') || '';\n        const match = currentTransform.match(/translate\\(([\\d.-]+),\\s*([\\d.-]+)\\)/);\n        const currentX = match ? parseFloat(match[1]) : 0;\n        const currentY = match ? parseFloat(match[2]) : 0;\n        const newX = 'x' in props ? props.x : currentX;\n        const newY = 'y' in props ? props.y : currentY;\n        element.setAttribute('transform', `translate(${newX}, ${newY})`);\n      }\n\n      // Apply other properties\n      for (const [key, value] of Object.entries(props)) {\n        if (key !== 'x' && key !== 'y') {\n          element.setAttribute(key, String(value));\n        }\n      }\n\n      setTimeout(resolve, duration);\n    });\n  }\n\n  /**\n   * Fade in an element\n   */\n  async fadeIn(element: SVGElement, duration: number = 300): Promise<void> {\n    element.style.opacity = '0';\n    element.style.transition = `opacity ${duration}ms ease-in`;\n\n    // Force reflow (getBoundingClientRect works on SVG elements)\n    element.getBoundingClientRect();\n\n    element.style.opacity = '1';\n    await new Promise((resolve) => setTimeout(resolve, duration));\n  }\n\n  /**\n   * Fade out an element\n   */\n  async fadeOut(element: SVGElement, duration: number = 300): Promise<void> {\n    element.style.transition = `opacity ${duration}ms ease-out`;\n    element.style.opacity = '0';\n    await new Promise((resolve) => setTimeout(resolve, duration));\n  }\n\n  /**\n   * Move an element to a new position\n   */\n  async moveTo(\n    element: SVGElement,\n    x: number,\n    y: number,\n    duration: number = 500\n  ): Promise<void> {\n    return this.animate(element, { x, y }, duration);\n  }\n\n  /**\n   * Highlight an element\n   */\n  async highlight(element: SVGElement, duration: number = 500): Promise<void> {\n    const originalFilter = element.getAttribute('filter') || '';\n    element.setAttribute('filter', 'url(#glow)');\n    await new Promise((resolve) => setTimeout(resolve, duration));\n    element.setAttribute('filter', originalFilter);\n  }\n\n  /**\n   * Add a pulsing effect to an element\n   */\n  pulse(element: SVGElement, duration: number = 1000): () => void {\n    // Use filter brightness instead of transform to avoid overriding translate\n    const animation = element.animate(\n      [\n        { filter: 'brightness(1)', opacity: 1 },\n        { filter: 'brightness(1.15)', opacity: 0.85 },\n        { filter: 'brightness(1)', opacity: 1 },\n      ],\n      {\n        duration,\n        iterations: Infinity,\n        easing: 'ease-in-out',\n      }\n    );\n\n    // Return cancel function\n    return () => animation.cancel();\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    this.svg.remove();\n    this.elements.clear();\n  }\n}\n", "/**\n * Core Animator class for orchestrating state machine animations\n *\n * This is the main entry point for the library. It manages the rendering,\n * animation queue, and provides high-level animation APIs.\n */\n\nimport type {\n  RendererConfig,\n  StateConfig,\n  StackConfig,\n  AnimationConfig,\n  AnimatorEvent,\n  AnimatorEventCallback,\n  ToolExecutionAnimation,\n  ArtifactCreationAnimation,\n  TransitionDiagramAnimation,\n  BranchAnimation,\n  MultiStackInteraction,\n  Point,\n  ElementRef,\n} from './types.js';\nimport { SVGRenderer } from '../renderers/SVGRenderer.js';\nimport {\n  dimensions,\n  getStatePositionInStack,\n  getConnectionPoints,\n} from '../utils/layout.js';\n\n/**\n * Animation queue item\n */\ninterface QueuedAnimation {\n  fn: () => Promise<void>;\n  config?: AnimationConfig;\n}\n\n/**\n * Internal stack state tracking\n */\ninterface StackState {\n  config: StackConfig;\n  position: Point;\n  ref: ElementRef;\n  stateRefs: ElementRef[]; // Track individual state elements for animation\n}\n\n/**\n * State Machine Animator\n */\nexport class StateMachineAnimator {\n  private renderer: SVGRenderer;\n  private animationQueue: QueuedAnimation[] = [];\n  private isPlaying: boolean = false;\n  private isPaused: boolean = false;\n  private speedMultiplier: number = 1;\n  private stacks: Map<string, StackState> = new Map();\n  private eventListeners: Map<AnimatorEvent, Set<AnimatorEventCallback>> = new Map();\n  private defaultAnimationDuration: number = 500;\n\n  constructor(config: RendererConfig) {\n    this.renderer = new SVGRenderer(config);\n  }\n\n  // ===========================================================================\n  // Playback Control\n  // ===========================================================================\n\n  /**\n   * Play queued animations\n   */\n  async play(): Promise<void> {\n    if (this.isPlaying) return;\n    this.isPlaying = true;\n    this.isPaused = false;\n\n    this.emit('animationStart');\n\n    while (this.animationQueue.length > 0 && !this.isPaused) {\n      const animation = this.animationQueue.shift();\n      if (animation) {\n        await animation.fn();\n      }\n    }\n\n    this.isPlaying = false;\n    this.emit('animationComplete');\n  }\n\n  /**\n   * Pause animations\n   */\n  pause(): void {\n    this.isPaused = true;\n  }\n\n  /**\n   * Resume paused animations\n   */\n  resume(): void {\n    if (this.isPaused) {\n      this.isPaused = false;\n      this.play();\n    }\n  }\n\n  /**\n   * Stop and clear animation queue\n   */\n  stop(): void {\n    this.animationQueue = [];\n    this.isPlaying = false;\n    this.isPaused = false;\n  }\n\n  /**\n   * Reset the animator and clear canvas\n   */\n  reset(): void {\n    this.stop();\n    this.renderer.clear();\n    this.renderer.resetView();\n    this.stacks.clear();\n  }\n\n  /**\n   * Set animation speed multiplier\n   */\n  setSpeed(multiplier: number): void {\n    this.speedMultiplier = Math.max(0.1, Math.min(10, multiplier));\n  }\n\n  /**\n   * Reset pan and zoom to default view\n   */\n  resetView(): void {\n    this.renderer.resetView();\n  }\n\n  /**\n   * Set zoom level (0.25 to 4)\n   */\n  setZoom(level: number): void {\n    this.renderer.setZoom(level);\n  }\n\n  /**\n   * Get current zoom level\n   */\n  getZoom(): number {\n    return this.renderer.getZoom();\n  }\n\n  /**\n   * Get effective duration with speed multiplier\n   */\n  private getDuration(baseDuration?: number): number {\n    const duration = baseDuration ?? this.defaultAnimationDuration;\n    return duration / this.speedMultiplier;\n  }\n\n  // ===========================================================================\n  // Event Handling\n  // ===========================================================================\n\n  /**\n   * Subscribe to animator events\n   */\n  on(event: AnimatorEvent, callback: AnimatorEventCallback): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event)!.add(callback);\n  }\n\n  /**\n   * Unsubscribe from animator events\n   */\n  off(event: AnimatorEvent, callback: AnimatorEventCallback): void {\n    this.eventListeners.get(event)?.delete(callback);\n  }\n\n  /**\n   * Emit an event\n   */\n  private emit(event: AnimatorEvent, data?: unknown): void {\n    this.eventListeners.get(event)?.forEach((callback) => callback(data));\n  }\n\n  // ===========================================================================\n  // Stack Management\n  // ===========================================================================\n\n  /**\n   * Add a stack to the visualization\n   */\n  addStack(stack: StackConfig, position?: Point): ElementRef {\n    const pos = position ?? { x: 40, y: 40 };\n    const ref = this.renderer.drawStack(stack, pos.x, pos.y);\n\n    this.stacks.set(stack.id, {\n      config: { ...stack },\n      position: pos,\n      ref,\n      stateRefs: ref.childRefs ? [...ref.childRefs] : [], // Capture initial state refs\n    });\n\n    return ref;\n  }\n\n  /**\n   * Remove a stack\n   */\n  removeStack(stackId: string): void {\n    const state = this.stacks.get(stackId);\n    if (state) {\n      this.renderer.removeElement(stackId);\n      this.stacks.delete(stackId);\n    }\n  }\n\n  /**\n   * Get a stack's current configuration\n   */\n  getStack(stackId: string): StackConfig | undefined {\n    return this.stacks.get(stackId)?.config;\n  }\n\n  // ===========================================================================\n  // Low-Level Animation Primitives\n  // ===========================================================================\n\n  /**\n   * Push a state onto a stack (animated)\n   */\n  async pushState(stackId: string, state: StateConfig): Promise<void> {\n    const stackState = this.stacks.get(stackId);\n    if (!stackState) {\n      throw new Error(`Stack not found: ${stackId}`);\n    }\n\n    const { config, position, stateRefs } = stackState;\n    const duration = this.getDuration();\n\n    // Calculate stack width\n    const stackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    // Total states after push\n    const totalStates = config.states.length + 1;\n\n    // First, animate all existing states down to their new positions\n    const moveAnimations: Promise<void>[] = [];\n    for (let i = 0; i < stateRefs.length; i++) {\n      const existingRef = stateRefs[i];\n      // Each existing state keeps its logical index but there's now one more state\n      const newPos = getStatePositionInStack(\n        position.x,\n        position.y,\n        stackWidth,\n        totalStates,\n        i // Same index, but totalStates increased so it moves down\n      );\n      moveAnimations.push(\n        this.renderer.moveTo(\n          existingRef.element as SVGElement,\n          newPos.x,\n          newPos.y,\n          duration / 2\n        )\n      );\n    }\n\n    // Wait for all existing states to move down\n    if (moveAnimations.length > 0) {\n      await Promise.all(moveAnimations);\n    }\n\n    // Calculate position for new state (at the top of stack)\n    const newIndex = config.states.length; // Will be the topmost (newest) state\n    const newStatePos = getStatePositionInStack(\n      position.x,\n      position.y,\n      stackWidth,\n      totalStates,\n      newIndex\n    );\n\n    // Create state above the stack (for drop-in animation)\n    const startY = newStatePos.y - 50;\n    const stateRef = this.renderer.drawState(state, newStatePos.x, startY);\n\n    // Fade in\n    await this.renderer.fadeIn(stateRef.element as SVGElement, duration / 2);\n\n    // Animate down to position\n    await this.renderer.moveTo(\n      stateRef.element as SVGElement,\n      newStatePos.x,\n      newStatePos.y,\n      duration / 2\n    );\n\n    // Update stack state\n    config.states.push(state);\n    stateRefs.push(stateRef);\n\n    this.emit('stateChange', { stackId, state, action: 'push' });\n  }\n\n  /**\n   * Pop a state from a stack (animated)\n   */\n  async popState(stackId: string): Promise<StateConfig | undefined> {\n    const stackState = this.stacks.get(stackId);\n    if (!stackState || stackState.config.states.length === 0) {\n      return undefined;\n    }\n\n    const { config } = stackState;\n\n    // Get the top state\n    const topState = config.states[config.states.length - 1];\n\n    // Remove from config (animation could be added in the future)\n\n    config.states.pop();\n\n    this.emit('stateChange', { stackId, state: topState, action: 'pop' });\n\n    return topState;\n  }\n\n  /**\n   * Highlight a specific state in a stack\n   */\n  async highlightState(stackId: string, _index: number): Promise<void> {\n    const stackState = this.stacks.get(stackId);\n    if (!stackState) return;\n\n    // TODO: Would need element tracking to highlight specific state\n    // For now, highlight the entire stack\n    await this.renderer.highlight(\n      stackState.ref.element as SVGElement,\n      this.getDuration()\n    );\n  }\n\n  /**\n   * Draw a connection between two elements\n   */\n  async drawConnection(\n    fromRef: ElementRef,\n    toRef: ElementRef,\n    animated: boolean = true\n  ): Promise<ElementRef> {\n    const { from, to } = getConnectionPoints(\n      fromRef.bounds,\n      toRef.bounds,\n      'right',\n      'left'\n    );\n\n    const arrowRef = this.renderer.drawArrow({\n      from,\n      to,\n      style: 'curved',\n      animated,\n    });\n\n    if (animated) {\n      await this.renderer.fadeIn(arrowRef.element as SVGElement, this.getDuration());\n    }\n\n    return arrowRef;\n  }\n\n  // ===========================================================================\n  // High-Level Animation APIs\n  // ===========================================================================\n\n  /**\n   * Play a tool execution animation\n   */\n  async playToolExecution(config: ToolExecutionAnimation): Promise<void> {\n    const duration = this.getDuration(config.options?.executionDuration || 500);\n\n    // Clear and set up\n    this.renderer.clear();\n\n    // Draw the initial stack\n    const stackRef = this.addStack(config.stack, { x: 60, y: 60 });\n    const stackState = this.stacks.get(config.stack.id)!;\n\n    // Calculate stack width (used for positioning calculations)\n    const stackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    // Calculate tool position - place it to the right, vertically centered\n    const toolX = stackRef.bounds.x + stackRef.bounds.width + dimensions.spacing.toolGap;\n    const toolY = 100; // Fixed Y position for stability\n\n    // Draw tool box (hidden initially)\n    const toolRef = this.renderer.drawTool(config.tool, toolX, toolY, true);\n\n    await this.delay(duration / 2);\n\n    // Push pre-states if any (e.g., AskOracle, OracleResponse before ToolCall)\n    if (config.preStates && config.preStates.length > 0) {\n      for (const state of config.preStates) {\n        await this.pushState(config.stack.id, state);\n        await this.delay(duration / 3);\n      }\n    }\n\n    // Animate trigger state (ToolCall) pushing onto stack\n    await this.pushState(config.stack.id, config.triggerState);\n\n    // Calculate the actual position of the ToolCall state (top of stack after push)\n    const toolCallIndex = stackState.config.states.length - 1;\n    const toolCallPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      stackState.config.states.length,\n      toolCallIndex\n    );\n\n    await this.delay(duration / 4);\n\n    // Fade in the tool box as we're about to connect to it\n    await this.renderer.fadeIn(toolRef.element as SVGElement, duration / 3);\n\n    // Draw arrow from ToolCall to tool (outgoing request) - anchored to bottom of tool\n    const arrow1 = this.renderer.drawArrow({\n      from: {\n        x: toolCallPos.x + dimensions.state.width,\n        y: toolCallPos.y + dimensions.state.height / 2,\n      },\n      to: {\n        x: toolRef.bounds.x,\n        y: toolRef.bounds.y + toolRef.bounds.height * 0.7,\n      },\n      style: config.options?.arrowStyle || 'curved',\n    });\n\n    await this.renderer.fadeIn(arrow1.element as SVGElement, duration / 3);\n\n    // Pulse tool (execution)\n    const cancelPulse = this.renderer.pulse(toolRef.element as SVGElement, 300);\n    await this.delay(duration);\n    cancelPulse();\n\n    // Calculate where the ToolResult will appear (at the top of the stack after push)\n    const totalStatesAfterResult = stackState.config.states.length + 1;\n    const resultPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      totalStatesAfterResult,\n      totalStatesAfterResult - 1 // The new top state\n    );\n\n    // Draw arrow from tool back to where result will appear (incoming response) - anchored from top of tool\n    const arrow2 = this.renderer.drawArrow({\n      from: {\n        x: toolRef.bounds.x,\n        y: toolRef.bounds.y + toolRef.bounds.height * 0.3,\n      },\n      to: {\n        x: resultPos.x + dimensions.state.width,\n        y: resultPos.y + dimensions.state.height / 2,\n      },\n      style: config.options?.arrowStyle || 'curved',\n    });\n\n    await this.renderer.fadeIn(arrow2.element as SVGElement, duration / 3);\n\n    await this.delay(duration / 4);\n\n    // Calculate where ToolCall will be after ToolResult is pushed\n    const newToolCallPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      stackState.config.states.length + 1, // After result is added\n      toolCallIndex // ToolCall stays at same index\n    );\n\n    // Push result state AND update arrow1 in parallel\n    // The arrow follows ToolCall as it moves down\n    await Promise.all([\n      this.pushState(config.stack.id, config.resultState),\n      this.renderer.updateArrowPath(\n        arrow1,\n        {\n          x: newToolCallPos.x + dimensions.state.width,\n          y: newToolCallPos.y + dimensions.state.height / 2,\n        },\n        {\n          x: toolRef.bounds.x,\n          y: toolRef.bounds.y + toolRef.bounds.height * 0.7,\n        },\n        config.options?.arrowStyle || 'curved',\n        duration / 2\n      ),\n    ]);\n\n    // Push post-states if any, updating arrows as ToolCall and ToolResult move down\n    if (config.postStates && config.postStates.length > 0) {\n      await this.delay(duration / 2);\n\n      // ToolResult is right above ToolCall (index = toolCallIndex + 1)\n      const toolResultIndex = toolCallIndex + 1;\n\n      for (const state of config.postStates) {\n        // Calculate new positions after this state is pushed\n        const nextTotalStates = stackState.config.states.length + 1;\n        const nextToolCallPos = getStatePositionInStack(\n          stackState.position.x,\n          stackState.position.y,\n          stackWidth,\n          nextTotalStates,\n          toolCallIndex\n        );\n        const nextToolResultPos = getStatePositionInStack(\n          stackState.position.x,\n          stackState.position.y,\n          stackWidth,\n          nextTotalStates,\n          toolResultIndex\n        );\n\n        // Push state and update both arrows in parallel\n        await Promise.all([\n          this.pushState(config.stack.id, state),\n          this.renderer.updateArrowPath(\n            arrow1,\n            {\n              x: nextToolCallPos.x + dimensions.state.width,\n              y: nextToolCallPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: toolRef.bounds.x,\n              y: toolRef.bounds.y + toolRef.bounds.height * 0.7,\n            },\n            config.options?.arrowStyle || 'curved',\n            duration / 4\n          ),\n          this.renderer.updateArrowPath(\n            arrow2,\n            {\n              x: toolRef.bounds.x,\n              y: toolRef.bounds.y + toolRef.bounds.height * 0.3,\n            },\n            {\n              x: nextToolResultPos.x + dimensions.state.width,\n              y: nextToolResultPos.y + dimensions.state.height / 2,\n            },\n            config.options?.arrowStyle || 'curved',\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 3);\n      }\n    }\n\n    this.emit('animationComplete', { type: 'toolExecution' });\n  }\n\n  /**\n   * Play an artifact creation animation.\n   * Shows a tool call creating an external artifact that stays attached to the interaction.\n   */\n  async playArtifactCreation(config: ArtifactCreationAnimation): Promise<void> {\n    const duration = this.getDuration();\n    const artifactPosition = config.options?.artifactPosition || 'right';\n\n    // Clear and set up\n    this.renderer.clear();\n\n    // Draw the initial stack\n    const stackRef = this.addStack(config.stack, { x: 60, y: 60 });\n    const stackState = this.stacks.get(config.stack.id)!;\n\n    // Calculate stack width\n    const stackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    await this.delay(duration / 2);\n\n    // Push pre-states if any\n    if (config.preStates && config.preStates.length > 0) {\n      for (const state of config.preStates) {\n        await this.pushState(config.stack.id, state);\n        await this.delay(duration / 3);\n      }\n    }\n\n    // Push the creator state (e.g., ToolCall that creates the artifact)\n    await this.pushState(config.stack.id, config.creatorState);\n\n    // Get creator state position\n    const creatorIndex = stackState.config.states.length - 1;\n    const creatorPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      stackState.config.states.length,\n      creatorIndex\n    );\n\n    await this.delay(duration / 2);\n\n    // Calculate artifact position\n    const artifactX =\n      artifactPosition === 'right'\n        ? stackRef.bounds.x + stackRef.bounds.width + 60\n        : stackRef.bounds.x - dimensions.artifact.width - 60;\n    const artifactY = creatorPos.y - 10;\n\n    // Draw artifact (hidden initially)\n    const artifactRef = this.renderer.drawArtifact(config.artifact, artifactX, artifactY, true);\n\n    // Draw arrow from creator state to artifact\n    const arrowFrom = {\n      x: artifactPosition === 'right'\n        ? creatorPos.x + dimensions.state.width\n        : creatorPos.x,\n      y: creatorPos.y + dimensions.state.height / 2,\n    };\n    const arrowTo = {\n      x: artifactPosition === 'right'\n        ? artifactRef.bounds.x\n        : artifactRef.bounds.x + artifactRef.bounds.width,\n      y: artifactRef.bounds.y + artifactRef.bounds.height / 2,\n    };\n\n    const arrow = this.renderer.drawArrow({\n      from: arrowFrom,\n      to: arrowTo,\n      style: config.options?.arrowStyle || 'curved',\n      hidden: true,\n    });\n\n    // Fade in artifact and arrow together\n    await Promise.all([\n      this.renderer.fadeIn(artifactRef.element as SVGElement, duration / 2),\n      this.renderer.fadeIn(arrow.element as SVGElement, duration / 2),\n    ]);\n\n    await this.delay(duration / 2);\n\n    // Push result state\n    // Calculate new positions after result is pushed\n    const newTotalStates = stackState.config.states.length + 1;\n    const newCreatorPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      newTotalStates,\n      creatorIndex\n    );\n\n    // Push result and update arrow in parallel\n    await Promise.all([\n      this.pushState(config.stack.id, config.resultState),\n      this.renderer.updateArrowPath(\n        arrow,\n        {\n          x: artifactPosition === 'right'\n            ? newCreatorPos.x + dimensions.state.width\n            : newCreatorPos.x,\n          y: newCreatorPos.y + dimensions.state.height / 2,\n        },\n        arrowTo,\n        config.options?.arrowStyle || 'curved',\n        duration / 4\n      ),\n      this.renderer.moveTo(\n        artifactRef.element as SVGElement,\n        artifactX,\n        newCreatorPos.y - 10,\n        duration / 4\n      ),\n    ]);\n\n    // Update arrow endpoint to match new artifact position\n    const newArrowTo = {\n      x: arrowTo.x,\n      y: newCreatorPos.y - 10 + artifactRef.bounds.height / 2,\n    };\n\n    await this.renderer.updateArrowPath(\n      arrow,\n      {\n        x: artifactPosition === 'right'\n          ? newCreatorPos.x + dimensions.state.width\n          : newCreatorPos.x,\n        y: newCreatorPos.y + dimensions.state.height / 2,\n      },\n      newArrowTo,\n      config.options?.arrowStyle || 'curved',\n      100\n    );\n\n    // Push post-states if any, updating arrow and artifact position each time\n    if (config.postStates && config.postStates.length > 0) {\n      for (const state of config.postStates) {\n        const nextTotalStates = stackState.config.states.length + 1;\n        const nextCreatorPos = getStatePositionInStack(\n          stackState.position.x,\n          stackState.position.y,\n          stackWidth,\n          nextTotalStates,\n          creatorIndex\n        );\n\n        const nextArtifactY = nextCreatorPos.y - 10;\n        const nextArrowTo = {\n          x: arrowTo.x,\n          y: nextArtifactY + artifactRef.bounds.height / 2,\n        };\n\n        await Promise.all([\n          this.pushState(config.stack.id, state),\n          this.renderer.updateArrowPath(\n            arrow,\n            {\n              x: artifactPosition === 'right'\n                ? nextCreatorPos.x + dimensions.state.width\n                : nextCreatorPos.x,\n              y: nextCreatorPos.y + dimensions.state.height / 2,\n            },\n            nextArrowTo,\n            config.options?.arrowStyle || 'curved',\n            duration / 4\n          ),\n          this.renderer.moveTo(\n            artifactRef.element as SVGElement,\n            artifactX,\n            nextArtifactY,\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 3);\n      }\n    }\n\n    this.emit('animationComplete', { type: 'artifactCreation' });\n  }\n\n  /**\n   * Play a state transition diagram animation\n   */\n  async playTransitionDiagram(config: TransitionDiagramAnimation): Promise<void> {\n    const duration = this.getDuration();\n\n    // Clear canvas\n    this.renderer.clear();\n\n    // Determine which states to show\n    const allStates: StateConfig[] = [\n      { type: config.initialState },\n      ...config.transitions.map((t) => ({ type: t })),\n    ];\n\n    // Remove duplicates\n    const uniqueStates = Array.from(\n      new Map(allStates.map((s) => [s.type, s])).values()\n    );\n\n    // Layout states in a flow\n    const layout = config.layout || 'horizontal';\n    const spacing = layout === 'horizontal' ? 180 : 80;\n    const stateRefs: Map<string, ElementRef> = new Map();\n\n    let x = 60;\n    let y = 100;\n\n    for (const state of uniqueStates) {\n      const ref = this.renderer.drawState(state, x, y);\n      stateRefs.set(state.type, ref);\n\n      if (layout === 'horizontal') {\n        x += spacing;\n      } else {\n        y += spacing;\n      }\n    }\n\n    // Draw transition arrows\n    const transitionSequence = [config.initialState, ...config.transitions];\n    for (let i = 0; i < transitionSequence.length - 1; i++) {\n      const fromRef = stateRefs.get(transitionSequence[i]);\n      const toRef = stateRefs.get(transitionSequence[i + 1]);\n\n      if (fromRef && toRef) {\n        const fromSide = layout === 'horizontal' ? 'right' : 'bottom';\n        const toSide = layout === 'horizontal' ? 'left' : 'top';\n\n        const { from, to } = getConnectionPoints(\n          fromRef.bounds,\n          toRef.bounds,\n          fromSide as 'right' | 'left' | 'top' | 'bottom',\n          toSide as 'right' | 'left' | 'top' | 'bottom'\n        );\n\n        this.renderer.drawArrow({ from, to, style: 'straight' });\n      }\n    }\n\n    // Animate through transitions\n    for (let i = 0; i < transitionSequence.length; i++) {\n      const currentState = transitionSequence[i];\n      const ref = stateRefs.get(currentState);\n\n      if (ref) {\n        await this.renderer.highlight(ref.element as SVGElement, duration);\n        await this.delay(duration / 2);\n      }\n    }\n\n    // If syncing with stack, draw it alongside\n    if (config.syncWithStack) {\n      const stackX =\n        config.syncWithStack.position === 'right'\n          ? x + 100\n          : config.syncWithStack.position === 'left'\n            ? -200\n            : 60;\n      const stackY = config.syncWithStack.position === 'bottom' ? y + 100 : 60;\n\n      this.addStack(config.syncWithStack.stack, { x: stackX, y: stackY });\n    }\n\n    this.emit('animationComplete', { type: 'transitionDiagram' });\n  }\n\n  /**\n   * Play a branching animation\n   */\n  async playBranching(config: BranchAnimation): Promise<void> {\n    const duration = this.getDuration();\n\n    // Clear canvas\n    this.renderer.clear();\n\n    // Draw source stack\n    const sourceRef = this.addStack(config.sourceStack, { x: 200, y: 60 });\n\n    await this.delay(duration);\n\n    // Highlight branch point\n    await this.highlightState(config.sourceStack.id, config.branchPoint);\n\n    await this.delay(duration / 2);\n\n    // Calculate branch positions\n    const branchStartX = 80;\n    const branchY = sourceRef.bounds.y + sourceRef.bounds.height + 80;\n    const branchSpacing = config.layout?.spacing ?? dimensions.spacing.branchGap;\n\n    // Draw label for branching\n    this.renderer.drawLabel('Branches', sourceRef.bounds.x + sourceRef.bounds.width / 2, branchY - 30, {\n      anchor: 'middle',\n      fontSize: 14,\n      fontWeight: '600',\n    });\n\n    // Create branch stacks\n    let x = branchStartX;\n    for (const branch of config.branches) {\n      // Create stack config for branch\n      const branchStack: StackConfig = {\n        id: branch.id,\n        label: branch.label || `Branch ${branch.id}`,\n        states: [\n          ...config.sourceStack.states.slice(0, config.branchPoint + 1),\n          ...branch.additionalStates,\n        ],\n        branchId: branch.id,\n        parentStackId: config.sourceStack.id,\n      };\n\n      const branchRef = this.renderer.drawStack(branchStack, x, branchY);\n      await this.renderer.fadeIn(branchRef.element as SVGElement, duration);\n\n      // Draw connection line from source to branch\n      const connectionFrom = {\n        x: sourceRef.bounds.x + sourceRef.bounds.width / 2,\n        y: sourceRef.bounds.y + sourceRef.bounds.height,\n      };\n      const connectionTo = {\n        x: branchRef.bounds.x + branchRef.bounds.width / 2,\n        y: branchRef.bounds.y,\n      };\n\n      this.renderer.drawArrow({\n        from: connectionFrom,\n        to: connectionTo,\n        style: 'curved',\n        dashArray: dimensions.arrow.dashArray,\n      });\n\n      this.stacks.set(branch.id, {\n        config: branchStack,\n        position: { x, y: branchY },\n        ref: branchRef,\n        stateRefs: [],\n      });\n\n      x += branchRef.bounds.width + branchSpacing;\n\n      await this.delay(duration / 2);\n\n      this.emit('branchCreated', { branchId: branch.id });\n    }\n\n    this.emit('animationComplete', { type: 'branching' });\n  }\n\n  /**\n   * Play a multi-stack interaction animation\n   */\n  async playMultiStackInteraction(config: MultiStackInteraction): Promise<void> {\n    const duration = this.getDuration();\n    const childPosition = config.options?.childPosition || 'right';\n\n    // Clear canvas\n    this.renderer.clear();\n\n    // Draw parent stack\n    const parentRef = this.addStack(config.parentStack, { x: 60, y: 60 });\n    const parentStackState = this.stacks.get(config.parentStack.id)!;\n\n    // Calculate stack widths for position calculations\n    const parentStackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n    const childStackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    // Calculate child position\n    const childX =\n      childPosition === 'right'\n        ? parentRef.bounds.x + parentRef.bounds.width + dimensions.spacing.stackGap\n        : parentRef.bounds.x;\n    const childY =\n      childPosition === 'below'\n        ? parentRef.bounds.y + parentRef.bounds.height + dimensions.spacing.stackGap\n        : parentRef.bounds.y;\n\n    // Draw child stack (initially empty)\n    const childStackConfig: StackConfig = {\n      ...config.childStack,\n      states: [],\n    };\n    this.addStack(childStackConfig, { x: childX, y: childY });\n    const childStackState = this.stacks.get(config.childStack.id)!;\n\n    await this.delay(duration);\n\n    // Animate parent execution steps before AgentCall\n    if (config.parentExecution && config.parentExecution.length > 0) {\n      if (config.options?.animateParentSteps !== false) {\n        for (const state of config.parentExecution) {\n          await this.pushState(config.parentStack.id, state);\n          await this.delay(duration / 2);\n        }\n      }\n    }\n\n    // Push call state onto parent\n    await this.pushState(config.parentStack.id, config.callState);\n\n    // Get AgentCall position for arrow start\n    const agentCallIndex = parentStackState.config.states.length - 1;\n    const agentCallPos = getStatePositionInStack(\n      parentStackState.position.x,\n      parentStackState.position.y,\n      parentStackWidth,\n      parentStackState.config.states.length,\n      agentCallIndex\n    );\n\n    await this.delay(duration / 2);\n\n    // Push first child state\n    if (config.childExecution.length > 0) {\n      await this.pushState(config.childStack.id, config.childExecution[0]);\n    }\n\n    // Calculate first child state position (it's at the top initially)\n    const firstChildStatePos = getStatePositionInStack(\n      childStackState.position.x,\n      childStackState.position.y,\n      childStackWidth,\n      1, // Only one state so far\n      0\n    );\n\n    // Draw arrow from AgentCall to first child state\n    const parentToChild = this.renderer.drawArrow({\n      from: {\n        x: agentCallPos.x + dimensions.state.width,\n        y: agentCallPos.y + dimensions.state.height / 2,\n      },\n      to: {\n        x: firstChildStatePos.x,\n        y: firstChildStatePos.y + dimensions.state.height / 2,\n      },\n      style: 'curved',\n      animated: true,\n    });\n\n    await this.renderer.fadeIn(parentToChild.element as SVGElement, duration / 2);\n\n    // Animate remaining child execution states\n    if (config.options?.animateChildSteps !== false && config.childExecution.length > 1) {\n      for (let i = 1; i < config.childExecution.length; i++) {\n        const state = config.childExecution[i];\n\n        // Calculate where first state will be after this push\n        const newFirstStatePos = getStatePositionInStack(\n          childStackState.position.x,\n          childStackState.position.y,\n          childStackWidth,\n          childStackState.config.states.length + 1,\n          0 // First state stays at index 0\n        );\n\n        // Push state and update arrow in parallel\n        await Promise.all([\n          this.pushState(config.childStack.id, state),\n          this.renderer.updateArrowPath(\n            parentToChild,\n            {\n              x: agentCallPos.x + dimensions.state.width,\n              y: agentCallPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: newFirstStatePos.x,\n              y: newFirstStatePos.y + dimensions.state.height / 2,\n            },\n            'curved',\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 2);\n      }\n    }\n\n    await this.delay(duration / 2);\n\n    // Get the position of the last child state (Finished)\n    const lastChildIndex = childStackState.config.states.length - 1;\n    const lastChildPos = getStatePositionInStack(\n      childStackState.position.x,\n      childStackState.position.y,\n      childStackWidth,\n      childStackState.config.states.length,\n      lastChildIndex\n    );\n\n    // Calculate where AgentResult will appear on parent stack\n    const agentResultPos = getStatePositionInStack(\n      parentStackState.position.x,\n      parentStackState.position.y,\n      parentStackWidth,\n      parentStackState.config.states.length + 1, // After result is added\n      parentStackState.config.states.length // New top state\n    );\n\n    // Draw arrow from last child state (Finished) to where AgentResult will be\n    const childToParent = this.renderer.drawArrow({\n      from: {\n        x: lastChildPos.x,\n        y: lastChildPos.y + dimensions.state.height / 2,\n      },\n      to: {\n        x: agentResultPos.x + dimensions.state.width,\n        y: agentResultPos.y + dimensions.state.height / 2,\n      },\n      style: 'curved',\n    });\n\n    await this.renderer.fadeIn(childToParent.element as SVGElement, duration / 2);\n\n    // Calculate where AgentCall will move to after result is pushed\n    const newAgentCallPos = getStatePositionInStack(\n      parentStackState.position.x,\n      parentStackState.position.y,\n      parentStackWidth,\n      parentStackState.config.states.length + 1,\n      agentCallIndex\n    );\n\n    // Push result onto parent and update parentToChild arrow in parallel\n    await Promise.all([\n      this.pushState(config.parentStack.id, config.resultState),\n      this.renderer.updateArrowPath(\n        parentToChild,\n        {\n          x: newAgentCallPos.x + dimensions.state.width,\n          y: newAgentCallPos.y + dimensions.state.height / 2,\n        },\n        {\n          x: firstChildStatePos.x,\n          y: getStatePositionInStack(\n            childStackState.position.x,\n            childStackState.position.y,\n            childStackWidth,\n            childStackState.config.states.length,\n            0\n          ).y + dimensions.state.height / 2,\n        },\n        'curved',\n        duration / 4\n      ),\n    ]);\n\n    // Animate parent completion steps after AgentResult\n    if (config.parentCompletion && config.parentCompletion.length > 0) {\n      await this.delay(duration / 2);\n\n      // Track indices - AgentResult was just pushed, so it's at the top\n      const agentResultIndex = parentStackState.config.states.length - 1;\n\n      // Get final positions of child states (they don't move anymore)\n      const finalFirstChildPos = getStatePositionInStack(\n        childStackState.position.x,\n        childStackState.position.y,\n        childStackWidth,\n        childStackState.config.states.length,\n        0\n      );\n      const finalLastChildPos = getStatePositionInStack(\n        childStackState.position.x,\n        childStackState.position.y,\n        childStackWidth,\n        childStackState.config.states.length,\n        childStackState.config.states.length - 1\n      );\n\n      for (const state of config.parentCompletion) {\n        // Calculate new positions after this state is pushed\n        const newTotalStates = parentStackState.config.states.length + 1;\n\n        const newAgentCallPos = getStatePositionInStack(\n          parentStackState.position.x,\n          parentStackState.position.y,\n          parentStackWidth,\n          newTotalStates,\n          agentCallIndex\n        );\n\n        const newAgentResultPos = getStatePositionInStack(\n          parentStackState.position.x,\n          parentStackState.position.y,\n          parentStackWidth,\n          newTotalStates,\n          agentResultIndex\n        );\n\n        // Push state and update both arrows in parallel\n        await Promise.all([\n          this.pushState(config.parentStack.id, state),\n          this.renderer.updateArrowPath(\n            parentToChild,\n            {\n              x: newAgentCallPos.x + dimensions.state.width,\n              y: newAgentCallPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: finalFirstChildPos.x,\n              y: finalFirstChildPos.y + dimensions.state.height / 2,\n            },\n            'curved',\n            duration / 4\n          ),\n          this.renderer.updateArrowPath(\n            childToParent,\n            {\n              x: finalLastChildPos.x,\n              y: finalLastChildPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: newAgentResultPos.x + dimensions.state.width,\n              y: newAgentResultPos.y + dimensions.state.height / 2,\n            },\n            'curved',\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 2);\n      }\n    }\n\n    this.emit('stackInteraction', {\n      parentId: config.parentStack.id,\n      childId: config.childStack.id,\n    });\n    this.emit('animationComplete', { type: 'multiStackInteraction' });\n  }\n\n  // ===========================================================================\n  // Utility Methods\n  // ===========================================================================\n\n  /**\n   * Wait for a duration\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get the renderer (for advanced usage)\n   */\n  getRenderer(): SVGRenderer {\n    return this.renderer;\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    this.stop();\n    this.renderer.destroy();\n    this.stacks.clear();\n    this.eventListeners.clear();\n  }\n}\n", "/**\n * Easing functions for smooth animations\n *\n * All functions take a progress value t in [0, 1] and return\n * a transformed value, also typically in [0, 1].\n */\n\nimport type { EasingFunction, EasingPreset } from '../core/types.js';\n\n/**\n * Linear - no easing\n */\nexport const linear: EasingFunction = (t) => t;\n\n/**\n * Quadratic easing\n */\nexport const easeInQuad: EasingFunction = (t) => t * t;\nexport const easeOutQuad: EasingFunction = (t) => t * (2 - t);\nexport const easeInOutQuad: EasingFunction = (t) =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\n/**\n * Cubic easing\n */\nexport const easeInCubic: EasingFunction = (t) => t * t * t;\nexport const easeOutCubic: EasingFunction = (t) => --t * t * t + 1;\nexport const easeInOutCubic: EasingFunction = (t) =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\n/**\n * Quartic easing\n */\nexport const easeInQuart: EasingFunction = (t) => t * t * t * t;\nexport const easeOutQuart: EasingFunction = (t) => 1 - --t * t * t * t;\nexport const easeInOutQuart: EasingFunction = (t) =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\n/**\n * Back easing - slight overshoot\n */\nconst c1 = 1.70158;\nconst c2 = c1 * 1.525;\nconst c3 = c1 + 1;\n\nexport const easeInBack: EasingFunction = (t) => c3 * t * t * t - c1 * t * t;\nexport const easeOutBack: EasingFunction = (t) =>\n  1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);\nexport const easeInOutBack: EasingFunction = (t) =>\n  t < 0.5\n    ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n    : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;\n\n/**\n * Elastic easing - springy effect\n */\nconst c4 = (2 * Math.PI) / 3;\nconst c5 = (2 * Math.PI) / 4.5;\n\nexport const easeInElastic: EasingFunction = (t) =>\n  t === 0\n    ? 0\n    : t === 1\n      ? 1\n      : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\n\nexport const easeOutElastic: EasingFunction = (t) =>\n  t === 0\n    ? 0\n    : t === 1\n      ? 1\n      : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n\nexport const easeInOutElastic: EasingFunction = (t) =>\n  t === 0\n    ? 0\n    : t === 1\n      ? 1\n      : t < 0.5\n        ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2\n        : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 +\n          1;\n\n/**\n * Bounce easing\n */\nexport const easeOutBounce: EasingFunction = (t) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (t < 1 / d1) {\n    return n1 * t * t;\n  } else if (t < 2 / d1) {\n    return n1 * (t -= 1.5 / d1) * t + 0.75;\n  } else if (t < 2.5 / d1) {\n    return n1 * (t -= 2.25 / d1) * t + 0.9375;\n  } else {\n    return n1 * (t -= 2.625 / d1) * t + 0.984375;\n  }\n};\n\nexport const easeInBounce: EasingFunction = (t) => 1 - easeOutBounce(1 - t);\nexport const easeInOutBounce: EasingFunction = (t) =>\n  t < 0.5\n    ? (1 - easeOutBounce(1 - 2 * t)) / 2\n    : (1 + easeOutBounce(2 * t - 1)) / 2;\n\n/**\n * Aliases for common easing names\n */\nexport const easeIn = easeInCubic;\nexport const easeOut = easeOutCubic;\nexport const easeInOut = easeInOutCubic;\n\n/**\n * Map of preset names to functions\n */\nexport const easingPresets: Record<EasingPreset, EasingFunction> = {\n  linear,\n  easeIn,\n  easeOut,\n  easeInOut,\n  easeInQuad,\n  easeOutQuad,\n  easeInOutQuad,\n  easeInCubic,\n  easeOutCubic,\n  easeInOutCubic,\n  easeInBack,\n  easeOutBack,\n  easeInOutBack,\n};\n\n/**\n * Get an easing function from a preset name or function\n */\nexport function getEasing(\n  easing: EasingFunction | EasingPreset | undefined\n): EasingFunction {\n  if (typeof easing === 'function') {\n    return easing;\n  }\n  if (typeof easing === 'string' && easing in easingPresets) {\n    return easingPresets[easing];\n  }\n  return easeInOutCubic; // Default\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "SVGRenderer", "StateMachineAnimator", "categoryLabels", "darkTheme", "dimensions", "easeIn", "easeInBack", "easeInBounce", "easeInCubic", "easeInOut", "easeInOutBack", "easeInOutCubic", "easeInOutQuad", "easeInQuad", "easeOut", "easeOutBack", "easeOutBounce", "easeOutCubic", "easeOutQuad", "easingPresets", "getEasing", "getStateCategory", "getStateColors", "getTheme", "lightTheme", "linear", "getStateCategory", "type", "lightTheme", "darkTheme", "getTheme", "theme", "getStateColors", "state", "category", "getStateCategory", "colors", "categoryLabels", "dimensions", "calculateStackHeight", "numStates", "stateSpacing", "padding", "labelHeight", "stateHeight", "getStatePositionInStack", "stackX", "stackY", "stackWidth", "totalStates", "stateIndex", "stateWidth", "x", "reversedIndex", "y", "getRectCenter", "rect", "getConnectionPoints", "from", "to", "fromSide", "toSide", "getPoint", "side", "getCurvedArrowPath", "midX", "midY", "dx", "dy", "curveOffset", "controlX", "controlY", "getSteppedArrowPath", "getStraightArrowPath", "SVG_NS", "createSVGElement", "tagName", "attributes", "element", "key", "value", "idCounter", "generateId", "prefix", "SVGRenderer", "config", "el", "getTheme", "e", "dx", "dy", "rect", "mouseX", "mouseY", "zoomFactor", "newZoom", "zoomRatio", "level", "bg", "textGroup", "state", "screenX", "screenY", "padding", "lineHeight", "currentY", "maxWidth", "typeText", "labelText", "dataEntries", "dataText", "valueStr", "tooltipWidth", "tooltipHeight", "svgRect", "tooltipX", "tooltipY", "x", "y", "dropShadow", "feGaussianBlur", "feOffset", "feFlood", "feComposite", "feMerge", "feMergeNode1", "feMergeNode2", "glow", "feGlow", "feMergeGlow", "feMergeGlowNode1", "feMergeGlowNode2", "arrowMarker", "arrowPath", "entries", "entry", "width", "height", "id", "colors", "getStateColors", "borderRadius", "fontSize", "labelFontSize", "dimensions", "group", "typeLabel", "detailLabel", "maxLen", "ref", "stack", "stackPadding", "minWidth", "stateWidth", "stackWidth", "stackHeight", "calculateStackHeight", "label", "sep", "stateRefs", "i", "statePos", "getStatePositionInStack", "stateRef", "from", "to", "arrow", "tool", "hidden", "displayText", "name", "artifact", "foldSize", "docPath", "doc", "foldPath", "fold", "icon", "iconText", "displayName", "options", "style", "strokeWidth", "color", "dashArray", "animated", "pathD", "getStraightArrowPath", "getSteppedArrowPath", "getCurvedArrowPath", "path", "minX", "minY", "maxX", "maxY", "arrowRef", "duration", "resolve", "text", "fontWeight", "anchor", "props", "match", "currentX", "newX", "newY", "originalFilter", "animation", "StateMachineAnimator", "config", "SVGRenderer", "animation", "multiplier", "level", "baseDuration", "event", "callback", "data", "stack", "position", "pos", "ref", "stackId", "state", "stackState", "stateRefs", "duration", "stackWidth", "dimensions", "totalStates", "moveAnimations", "i", "existingRef", "newPos", "getStatePositionInStack", "newIndex", "newStatePos", "startY", "stateRef", "topState", "_index", "fromRef", "toRef", "animated", "from", "to", "getConnectionPoints", "arrowRef", "stackRef", "toolX", "toolRef", "toolCallIndex", "toolCallPos", "arrow1", "cancelPulse", "totalStatesAfterResult", "resultPos", "arrow2", "newToolCallPos", "toolResultIndex", "nextTotalStates", "nextToolCallPos", "nextToolResultPos", "artifactPosition", "creatorIndex", "creatorPos", "artifactX", "artifactY", "artifactRef", "arrowFrom", "arrowTo", "arrow", "newTotalStates", "newCreatorPos", "newArrowTo", "nextCreatorPos", "nextArtifactY", "nextArrowTo", "allStates", "t", "uniqueStates", "s", "layout", "spacing", "x", "y", "transitionSequence", "fromSide", "toSide", "currentState", "stackX", "stackY", "sourceRef", "branchStartX", "branchY", "branchSpacing", "branch", "branchStack", "branchRef", "connectionFrom", "connectionTo", "childPosition", "parentRef", "parentStackState", "parentStackWidth", "childStackWidth", "childX", "childY", "childStackConfig", "childStackState", "agentCallIndex", "agentCallPos", "firstChildStatePos", "parentToChild", "newFirstStatePos", "lastChildIndex", "lastChildPos", "agentResultPos", "childToParent", "newAgentCallPos", "agentResultIndex", "finalFirstChildPos", "finalLastChildPos", "newAgentResultPos", "ms", "resolve", "linear", "t", "easeInQuad", "easeOutQuad", "easeInOutQuad", "easeInCubic", "easeOutCubic", "easeInOutCubic", "c2", "c3", "easeInBack", "t", "easeOutBack", "easeInOutBack", "c4", "c5", "easeOutBounce", "t", "easeInBounce", "easeIn", "easeInCubic", "easeOut", "easeOutCubic", "easeInOut", "easeInOutCubic", "easingPresets", "linear", "easeInQuad", "easeOutQuad", "easeInOutQuad", "easeInBack", "easeOutBack", "easeInOutBack", "getEasing", "easing"]
}
