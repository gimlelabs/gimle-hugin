{
  "version": 3,
  "sources": ["../src/core/types.ts", "../src/utils/colors.ts", "../src/utils/layout.ts", "../src/renderers/SVGRenderer.ts", "../src/core/Animator.ts", "../src/utils/easing.ts"],
  "sourcesContent": ["/**\n * Core type definitions for the State Machine Animator\n *\n * These types align with the Hugin agent framework's interaction model\n * while providing flexibility for custom visualizations.\n */\n\n// =============================================================================\n// State Types\n// =============================================================================\n\n/**\n * Standard state types from the Hugin framework.\n * Maps to interaction types in the Python codebase.\n */\nexport type StateType =\n  // Task Interactions\n  | 'TaskDefinition'\n  | 'TaskResult'\n  | 'TaskChain'\n  // LLM/Oracle Interactions\n  | 'AskOracle'\n  | 'OracleResponse'\n  // Tool Interactions\n  | 'ToolCall'\n  | 'ToolResult'\n  // Agent Interactions (sub-agents)\n  | 'AgentCall'\n  | 'AgentResult'\n  // Human Interactions\n  | 'AskHuman'\n  | 'HumanResponse'\n  | 'ExternalInput'\n  // Control Flow\n  | 'Waiting'\n  // Generic/custom (for backwards compatibility or custom visualizations)\n  | 'Custom';\n\n/**\n * Categories for grouping state types by their nature.\n * Used for color coding and layout grouping.\n */\nexport type StateCategory =\n  | 'llm' // LLM/Oracle interactions (yellow)\n  | 'tool' // Tool interactions (blue)\n  | 'agent' // Agent/Task interactions (purple)\n  | 'user' // User/Human interactions (orange)\n  | 'terminal'; // Terminal states (green/gray)\n\n/**\n * Get the category for a state type\n */\nexport function getStateCategory(type: StateType): StateCategory {\n  switch (type) {\n    // LLM/Oracle interactions (yellow)\n    case 'AskOracle':\n    case 'OracleResponse':\n      return 'llm';\n    // Tool interactions (blue)\n    case 'ToolCall':\n    case 'ToolResult':\n      return 'tool';\n    // Agent/Task interactions (purple)\n    case 'AgentCall':\n    case 'AgentResult':\n    case 'TaskDefinition':\n    case 'TaskChain':\n      return 'agent';\n    // Human interactions (orange)\n    case 'AskHuman':\n    case 'HumanResponse':\n    case 'ExternalInput':\n      return 'user';\n    // Terminal/control states (green)\n    case 'TaskResult':\n    case 'Waiting':\n      return 'terminal';\n    default:\n      return 'agent'; // Default for custom types\n  }\n}\n\n// =============================================================================\n// State Configuration\n// =============================================================================\n\n/**\n * Configuration for a single state in the visualization\n */\nexport interface StateConfig {\n  /** The type of state */\n  type: StateType;\n  /** Optional display label (defaults to type name) */\n  label?: string;\n  /** Optional metadata for custom rendering */\n  data?: Record<string, unknown>;\n  /** Override the default color for this state */\n  color?: string;\n  /** Optional border color override */\n  borderColor?: string;\n  /** Unique identifier for this state instance */\n  id?: string;\n}\n\n// =============================================================================\n// Stack Configuration\n// =============================================================================\n\n/**\n * Configuration for an interaction stack\n */\nexport interface StackConfig {\n  /** Unique identifier for this stack */\n  id: string;\n  /** Display label for the stack */\n  label?: string;\n  /** States in this stack (bottom to top) */\n  states: StateConfig[];\n  /** Branch identifier (for branched stacks) */\n  branchId?: string;\n  /** Parent stack ID (for sub-agent stacks) */\n  parentStackId?: string;\n  /** Optional metadata */\n  data?: Record<string, unknown>;\n}\n\n// =============================================================================\n// Tool Configuration\n// =============================================================================\n\n/**\n * Configuration for a tool in the visualization\n */\nexport interface ToolConfig {\n  /** Unique identifier */\n  id: string;\n  /** Display name */\n  name: string;\n  /** Optional icon (emoji or URL) */\n  icon?: string;\n  /** Override color */\n  color?: string;\n  /** Optional description */\n  description?: string;\n}\n\n// =============================================================================\n// Artifact Configuration\n// =============================================================================\n\n/**\n * Configuration for an artifact in the visualization.\n * Artifacts are external outputs created by tool calls (e.g., PDF documents, files).\n */\nexport interface ArtifactConfig {\n  /** Unique identifier */\n  id: string;\n  /** Display name */\n  name: string;\n  /** Artifact type (for icon selection) */\n  type?: 'document' | 'image' | 'data' | 'code' | 'generic';\n  /** Optional icon (emoji or URL) */\n  icon?: string;\n  /** Override color */\n  color?: string;\n  /** Optional file extension to display */\n  extension?: string;\n}\n\n// =============================================================================\n// Animation Configuration\n// =============================================================================\n\n/**\n * Easing function type\n */\nexport type EasingFunction = (t: number) => number;\n\n/**\n * Named easing presets\n */\nexport type EasingPreset =\n  | 'linear'\n  | 'easeIn'\n  | 'easeOut'\n  | 'easeInOut'\n  | 'easeInQuad'\n  | 'easeOutQuad'\n  | 'easeInOutQuad'\n  | 'easeInCubic'\n  | 'easeOutCubic'\n  | 'easeInOutCubic'\n  | 'easeInBack'\n  | 'easeOutBack'\n  | 'easeInOutBack';\n\n/**\n * Configuration for individual animations\n */\nexport interface AnimationConfig {\n  /** Duration in milliseconds (default: 500) */\n  duration?: number;\n  /** Easing function or preset name */\n  easing?: EasingFunction | EasingPreset;\n  /** Delay before starting (ms) */\n  delay?: number;\n  /** Callback when animation starts */\n  onStart?: () => void;\n  /** Callback when animation completes */\n  onComplete?: () => void;\n}\n\n// =============================================================================\n// Theme Configuration\n// =============================================================================\n\n/**\n * Color configuration for state categories\n */\nexport interface StateCategoryColors {\n  /** Background color */\n  background: string;\n  /** Border color */\n  border: string;\n  /** Text color (optional, defaults to theme text color) */\n  text?: string;\n}\n\n/**\n * Full theme configuration\n */\nexport interface ThemeConfig {\n  /** Canvas/SVG background */\n  background: string;\n  /** Colors for each state category */\n  stateColors: Record<StateCategory, StateCategoryColors>;\n  /** Default text color */\n  textColor: string;\n  /** Arrow/connector color */\n  arrowColor: string;\n  /** Stack container background */\n  stackBackground: string;\n  /** Stack border color */\n  stackBorderColor: string;\n  /** Tool box color */\n  toolColor: string;\n  /** Tool box border */\n  toolBorderColor: string;\n  /** Font family */\n  fontFamily: string;\n}\n\n// =============================================================================\n// Renderer Configuration\n// =============================================================================\n\n/**\n * Configuration for the renderer\n */\nexport interface RendererConfig {\n  /** Container element or CSS selector */\n  container: HTMLElement | string;\n  /** Canvas width (default: auto) */\n  width?: number;\n  /** Canvas height (default: auto) */\n  height?: number;\n  /** Theme preset or custom config */\n  theme?: 'light' | 'dark' | ThemeConfig;\n  /** Enable responsive sizing */\n  responsive?: boolean;\n  /** Padding inside the canvas */\n  padding?: number;\n}\n\n// =============================================================================\n// Animation Types\n// =============================================================================\n\n/**\n * Configuration for tool execution animation\n */\nexport interface ToolExecutionAnimation {\n  /** The stack receiving the states */\n  stack: StackConfig;\n  /** States to push before the tool call */\n  preStates?: StateConfig[];\n  /** The state that triggers the tool call */\n  triggerState: StateConfig;\n  /** The tool being executed */\n  tool: ToolConfig;\n  /** The result state pushed after execution */\n  resultState: StateConfig;\n  /** States to push after the tool result */\n  postStates?: StateConfig[];\n  /** Animation options */\n  options?: {\n    /** Show tool name/icon */\n    showToolDetails?: boolean;\n    /** How long tool \"runs\" in ms */\n    executionDuration?: number;\n    /** Arrow style */\n    arrowStyle?: 'straight' | 'curved' | 'stepped';\n  };\n}\n\n/**\n * Configuration for artifact creation animation.\n * Shows a tool call creating an external artifact that stays attached to the interaction.\n */\nexport interface ArtifactCreationAnimation {\n  /** The stack receiving the states */\n  stack: StackConfig;\n  /** States to push before the artifact-creating tool call */\n  preStates?: StateConfig[];\n  /** The state that creates the artifact (typically a ToolCall) */\n  creatorState: StateConfig;\n  /** The artifact being created */\n  artifact: ArtifactConfig;\n  /** The result state pushed after creation */\n  resultState: StateConfig;\n  /** States to push after the artifact is created */\n  postStates?: StateConfig[];\n  /** Animation options */\n  options?: {\n    /** Position of artifact relative to stack */\n    artifactPosition?: 'right' | 'left';\n    /** Arrow style */\n    arrowStyle?: 'straight' | 'curved' | 'stepped';\n  };\n}\n\n/**\n * Configuration for state transition diagram animation\n */\nexport interface TransitionDiagramAnimation {\n  /** Which states to show */\n  visibleStates?: StateType[] | 'all';\n  /** Starting state */\n  initialState: StateType;\n  /** Sequence of transitions to animate */\n  transitions: StateType[];\n  /** Sync with a stack view */\n  syncWithStack?: {\n    stack: StackConfig;\n    position: 'left' | 'right' | 'bottom';\n  };\n  /** Layout style */\n  layout?: 'horizontal' | 'vertical' | 'circular';\n}\n\n/**\n * Configuration for branching animation\n */\nexport interface BranchAnimation {\n  /** Original stack before branching */\n  sourceStack: StackConfig;\n  /** Point at which branching occurs (index in stack) */\n  branchPoint: number;\n  /** The branched stacks */\n  branches: Array<{\n    id: string;\n    label?: string;\n    additionalStates: StateConfig[];\n  }>;\n  /** Layout options */\n  layout?: {\n    direction: 'horizontal' | 'vertical';\n    spacing: number;\n  };\n}\n\n/**\n * Configuration for multi-stack interaction animation\n */\nexport interface MultiStackInteraction {\n  /** The initiating stack (parent agent) */\n  parentStack: StackConfig;\n  /** The receiving stack (sub-agent) */\n  childStack: StackConfig;\n  /** States to push on parent before the AgentCall */\n  parentExecution?: StateConfig[];\n  /** The call state on parent (AgentCall) */\n  callState: StateConfig;\n  /** States that execute on child */\n  childExecution: StateConfig[];\n  /** The result returned to parent */\n  resultState: StateConfig;\n  /** States to push on parent after the AgentResult */\n  parentCompletion?: StateConfig[];\n  /** Visual options */\n  options?: {\n    /** Show message content */\n    showMessageContent?: boolean;\n    /** Child stack position */\n    childPosition?: 'right' | 'below';\n    /** Animate each child step or just result */\n    animateChildSteps?: boolean;\n    /** Animate parent steps before AgentCall */\n    animateParentSteps?: boolean;\n  };\n}\n\n// =============================================================================\n// Event Types\n// =============================================================================\n\n/**\n * Events emitted by the animator\n */\nexport type AnimatorEvent =\n  | 'animationStart'\n  | 'animationComplete'\n  | 'animationStep'\n  | 'stateChange'\n  | 'branchCreated'\n  | 'stackInteraction'\n  | 'error';\n\n/**\n * Event callback signature\n */\nexport type AnimatorEventCallback = (data?: unknown) => void;\n\n// =============================================================================\n// Geometry Types\n// =============================================================================\n\n/**\n * 2D point\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * Rectangle bounds\n */\nexport interface Rect {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Arrow connection options\n */\nexport interface ArrowOptions {\n  /** Start point */\n  from: Point;\n  /** End point */\n  to: Point;\n  /** Arrow style */\n  style?: 'straight' | 'curved' | 'stepped';\n  /** Show arrowhead */\n  showHead?: boolean;\n  /** Stroke width */\n  strokeWidth?: number;\n  /** Color */\n  color?: string;\n  /** Dash pattern (for \"in progress\" arrows) */\n  dashArray?: string;\n  /** Animation style */\n  animated?: boolean;\n  /** Start hidden (opacity 0) */\n  hidden?: boolean;\n}\n\n// =============================================================================\n// Visual Element References\n// =============================================================================\n\n/**\n * Reference to a rendered element\n */\nexport interface ElementRef {\n  /** Element type */\n  type: 'state' | 'stack' | 'tool' | 'artifact' | 'arrow' | 'label';\n  /** Unique ID */\n  id: string;\n  /** DOM/SVG element */\n  element: SVGElement | HTMLElement;\n  /** Bounding box */\n  bounds: Rect;\n  /** Child element refs (e.g., state refs within a stack) */\n  childRefs?: ElementRef[];\n}\n", "/**\n * Color schemes and theme definitions\n *\n * These colors match Erik's Funhouse blog styling for state machine diagrams.\n * The design is flat with colored backgrounds and slightly darker borders.\n */\n\nimport type { ThemeConfig, StateCategory, StateConfig } from '../core/types.js';\nimport { getStateCategory } from '../core/types.js';\n\n/**\n * Light theme - matches Erik's Funhouse blog styling\n *\n * Colors from the state machine diagrams:\n * - Yellow for LLM interactions\n * - Blue for Tool interactions\n * - Pink/Salmon for User interactions\n * - Lavender for Agent interactions\n * - Green for Terminal/Finished states\n */\nexport const lightTheme: ThemeConfig = {\n  background: '#ffffff',\n\n  stateColors: {\n    // Yellow - LLM interactions (UserMessage, AssistantMessage)\n    llm: {\n      background: '#FFE082',\n      border: '#E6C200',\n      text: '#000000',\n    },\n    // Blue - Tool interactions (ToolCall, ToolResult)\n    tool: {\n      background: '#90CAF9',\n      border: '#5BA3E0',\n      text: '#000000',\n    },\n    // Lavender/Purple - Agent interactions (AgentCall, AgentResult)\n    agent: {\n      background: '#D1C4E9',\n      border: '#A094C0',\n      text: '#000000',\n    },\n    // Pink/Salmon - User interactions (UserInputRequired, UserResponse)\n    user: {\n      background: '#FFCDD2',\n      border: '#E0A0A5',\n      text: '#000000',\n    },\n    // Green - Terminal states (Finished)\n    terminal: {\n      background: '#A5D6A7',\n      border: '#70B873',\n      text: '#000000',\n    },\n  },\n\n  textColor: '#000000',\n  arrowColor: '#424242',\n  stackBackground: 'transparent',\n  stackBorderColor: 'transparent',\n  // Orange/Peach for \"execution\" boxes (Tool Execution, LLM Call, etc.)\n  toolColor: '#FFCC80',\n  toolBorderColor: '#E6A550',\n  fontFamily:\n    \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif\",\n};\n\n/**\n * Dark theme for dark mode contexts\n */\nexport const darkTheme: ThemeConfig = {\n  background: '#1a1a2e',\n\n  stateColors: {\n    // Yellow - LLM/Oracle interactions\n    llm: {\n      background: '#3d3d00',\n      border: '#fbc02d',\n      text: '#fff9c4',\n    },\n    // Blue - Tool interactions\n    tool: {\n      background: '#0d2137',\n      border: '#5dade2',\n      text: '#e3f2fd',\n    },\n    // Purple - Agent/Task interactions\n    agent: {\n      background: '#2d1f3d',\n      border: '#bb8fce',\n      text: '#f3e5f5',\n    },\n    // Orange - User/Human interactions\n    user: {\n      background: '#3d2600',\n      border: '#f5b041',\n      text: '#fff3e0',\n    },\n    // Green/Gray - Terminal states\n    terminal: {\n      background: '#1a3d1f',\n      border: '#58d68d',\n      text: '#e8f5e9',\n    },\n  },\n\n  textColor: '#eaecee',\n  arrowColor: '#5dade2',\n  stackBackground: '#2d2d44',\n  stackBorderColor: '#3d3d5c',\n  toolColor: '#1a2f3d',\n  toolBorderColor: '#5dade2',\n  fontFamily:\n    \"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif\",\n};\n\n/**\n * Get theme by name or return custom theme\n */\nexport function getTheme(theme: 'light' | 'dark' | ThemeConfig): ThemeConfig {\n  if (theme === 'light') return lightTheme;\n  if (theme === 'dark') return darkTheme;\n  return theme;\n}\n\n/**\n * Get colors for a state based on its type and theme\n */\nexport function getStateColors(\n  state: StateConfig,\n  theme: ThemeConfig\n): { background: string; border: string; text: string } {\n  // Allow per-state color overrides\n  if (state.color || state.borderColor) {\n    return {\n      background: state.color || theme.stateColors.agent.background,\n      border: state.borderColor || state.color || theme.stateColors.agent.border,\n      text: theme.textColor,\n    };\n  }\n\n  const category = getStateCategory(state.type);\n  const colors = theme.stateColors[category];\n\n  return {\n    background: colors.background,\n    border: colors.border,\n    text: colors.text || theme.textColor,\n  };\n}\n\n/**\n * Lighten a hex color by a percentage\n */\nexport function lighten(hex: string, percent: number): string {\n  const num = parseInt(hex.replace('#', ''), 16);\n  const amt = Math.round(2.55 * percent);\n  const R = Math.min(255, (num >> 16) + amt);\n  const G = Math.min(255, ((num >> 8) & 0x00ff) + amt);\n  const B = Math.min(255, (num & 0x0000ff) + amt);\n  return `#${((1 << 24) | (R << 16) | (G << 8) | B).toString(16).slice(1)}`;\n}\n\n/**\n * Darken a hex color by a percentage\n */\nexport function darken(hex: string, percent: number): string {\n  const num = parseInt(hex.replace('#', ''), 16);\n  const amt = Math.round(2.55 * percent);\n  const R = Math.max(0, (num >> 16) - amt);\n  const G = Math.max(0, ((num >> 8) & 0x00ff) - amt);\n  const B = Math.max(0, (num & 0x0000ff) - amt);\n  return `#${((1 << 24) | (R << 16) | (G << 8) | B).toString(16).slice(1)}`;\n}\n\n/**\n * Add transparency to a hex color\n */\nexport function withAlpha(hex: string, alpha: number): string {\n  const num = parseInt(hex.replace('#', ''), 16);\n  const R = num >> 16;\n  const G = (num >> 8) & 0x00ff;\n  const B = num & 0x0000ff;\n  return `rgba(${R}, ${G}, ${B}, ${alpha})`;\n}\n\n/**\n * Category labels for legend/documentation\n */\nexport const categoryLabels: Record<StateCategory, string> = {\n  llm: 'LLM Interaction',\n  tool: 'Tool Execution',\n  agent: 'Agent/Task',\n  user: 'User Input',\n  terminal: 'Terminal',\n};\n", "/**\n * Layout utilities for positioning elements\n */\n\nimport type { Point, Rect, StackConfig, StateConfig } from '../core/types.js';\n\n/**\n * Default dimensions for visual elements\n *\n * These match the Erik's Funhouse blog style:\n * - Generous border radius (~14px)\n * - Clean spacing\n * - Thin arrows\n */\nexport const dimensions = {\n  state: {\n    width: 165,\n    height: 42,\n    borderRadius: 14, // Generous rounded corners like the blog\n    padding: 12,\n    fontSize: 15,\n    labelFontSize: 11,\n  },\n  stack: {\n    stateSpacing: 4, // Small gap between states\n    padding: 0, // No container padding (floating boxes)\n    labelHeight: 40, // Height for stack label area (includes spacing below label)\n    minWidth: 170,\n    borderRadius: 14,\n  },\n  tool: {\n    width: 140,\n    height: 44,\n    borderRadius: 14, // Match state border radius\n    iconSize: 18,\n  },\n  artifact: {\n    width: 100,\n    height: 70,\n    foldSize: 16, // Size of the folded corner\n    borderRadius: 4, // Smaller radius for document look\n  },\n  arrow: {\n    strokeWidth: 1.5, // Thin arrows like the blog\n    headSize: 6,\n    dashArray: '5,5',\n  },\n  spacing: {\n    stackGap: 80, // Gap between stacks\n    toolGap: 50, // Gap between stack and tool\n    branchGap: 50, // Gap between branches\n  },\n};\n\n/**\n * Calculate the height of a stack based on number of states\n */\nexport function calculateStackHeight(numStates: number): number {\n  const { stateSpacing, padding, labelHeight } = dimensions.stack;\n  const { height: stateHeight } = dimensions.state;\n\n  if (numStates === 0) {\n    return labelHeight + padding * 2 + stateHeight; // Show at least space for one state\n  }\n\n  return (\n    labelHeight +\n    padding * 2 +\n    numStates * stateHeight +\n    (numStates - 1) * stateSpacing\n  );\n}\n\n/**\n * Calculate position of a state within a stack\n * Index 0 is the bottom of the stack (first state added)\n */\nexport function getStatePositionInStack(\n  stackX: number,\n  stackY: number,\n  stackWidth: number,\n  totalStates: number,\n  stateIndex: number\n): Point {\n  const { stateSpacing, padding, labelHeight } = dimensions.stack;\n  const { height: stateHeight, width: stateWidth } = dimensions.state;\n\n  // Center state horizontally in stack\n  const x = stackX + (stackWidth - stateWidth) / 2;\n\n  // Position from top, but logically index from bottom\n  // So index 0 appears at the bottom, index n-1 at the top\n  const reversedIndex = totalStates - 1 - stateIndex;\n  const y =\n    stackY + labelHeight + padding + reversedIndex * (stateHeight + stateSpacing);\n\n  return { x, y };\n}\n\n/**\n * Calculate the bounds of a stack\n */\nexport function getStackBounds(\n  stack: StackConfig,\n  position: Point\n): Rect {\n  const height = calculateStackHeight(stack.states.length);\n  const width = Math.max(\n    dimensions.stack.minWidth,\n    dimensions.state.width + dimensions.stack.padding * 2\n  );\n\n  return {\n    x: position.x,\n    y: position.y,\n    width,\n    height,\n  };\n}\n\n/**\n * Calculate center point of a rectangle\n */\nexport function getRectCenter(rect: Rect): Point {\n  return {\n    x: rect.x + rect.width / 2,\n    y: rect.y + rect.height / 2,\n  };\n}\n\n/**\n * Calculate connection points for arrows between elements\n */\nexport function getConnectionPoints(\n  from: Rect,\n  to: Rect,\n  fromSide: 'top' | 'bottom' | 'left' | 'right' = 'right',\n  toSide: 'top' | 'bottom' | 'left' | 'right' = 'left'\n): { from: Point; to: Point } {\n  const getPoint = (rect: Rect, side: string): Point => {\n    switch (side) {\n      case 'top':\n        return { x: rect.x + rect.width / 2, y: rect.y };\n      case 'bottom':\n        return { x: rect.x + rect.width / 2, y: rect.y + rect.height };\n      case 'left':\n        return { x: rect.x, y: rect.y + rect.height / 2 };\n      case 'right':\n        return { x: rect.x + rect.width, y: rect.y + rect.height / 2 };\n      default:\n        return getRectCenter(rect);\n    }\n  };\n\n  return {\n    from: getPoint(from, fromSide),\n    to: getPoint(to, toSide),\n  };\n}\n\n/**\n * Generate SVG path for a curved arrow\n */\nexport function getCurvedArrowPath(from: Point, to: Point): string {\n  const midX = (from.x + to.x) / 2;\n  const midY = (from.y + to.y) / 2;\n\n  // Calculate control points for a smooth curve\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n\n  // Offset perpendicular to the line for curve\n  const curveOffset = Math.min(Math.abs(dx), Math.abs(dy)) * 0.3;\n\n  // Simple quadratic curve\n  const controlX = midX;\n  const controlY = midY - curveOffset;\n\n  return `M ${from.x} ${from.y} Q ${controlX} ${controlY} ${to.x} ${to.y}`;\n}\n\n/**\n * Generate SVG path for a stepped arrow (right-angle turns)\n */\nexport function getSteppedArrowPath(from: Point, to: Point): string {\n  const midX = (from.x + to.x) / 2;\n\n  return `M ${from.x} ${from.y} L ${midX} ${from.y} L ${midX} ${to.y} L ${to.x} ${to.y}`;\n}\n\n/**\n * Generate SVG path for a straight arrow\n */\nexport function getStraightArrowPath(from: Point, to: Point): string {\n  return `M ${from.x} ${from.y} L ${to.x} ${to.y}`;\n}\n\n/**\n * Calculate arrowhead points\n */\nexport function getArrowheadPoints(\n  to: Point,\n  from: Point,\n  size: number = dimensions.arrow.headSize\n): string {\n  const angle = Math.atan2(to.y - from.y, to.x - from.x);\n  const angle1 = angle + Math.PI * 0.8;\n  const angle2 = angle - Math.PI * 0.8;\n\n  const x1 = to.x + size * Math.cos(angle1);\n  const y1 = to.y + size * Math.sin(angle1);\n  const x2 = to.x + size * Math.cos(angle2);\n  const y2 = to.y + size * Math.sin(angle2);\n\n  return `${to.x},${to.y} ${x1},${y1} ${x2},${y2}`;\n}\n\n/**\n * Layout multiple stacks horizontally\n */\nexport function layoutStacksHorizontally(\n  stacks: StackConfig[],\n  startX: number,\n  startY: number\n): Map<string, Point> {\n  const positions = new Map<string, Point>();\n  let currentX = startX;\n\n  for (const stack of stacks) {\n    positions.set(stack.id, { x: currentX, y: startY });\n    const bounds = getStackBounds(stack, { x: currentX, y: startY });\n    currentX += bounds.width + dimensions.spacing.stackGap;\n  }\n\n  return positions;\n}\n\n/**\n * Layout branches from a source stack\n */\nexport function layoutBranches(\n  sourceStack: StackConfig,\n  branches: Array<{ id: string; states: StateConfig[] }>,\n  sourcePosition: Point,\n  branchPoint: number\n): Map<string, Point> {\n  const positions = new Map<string, Point>();\n  const sourceBounds = getStackBounds(sourceStack, sourcePosition);\n\n  // Calculate Y position for branch point\n  const branchY =\n    sourcePosition.y +\n    dimensions.stack.labelHeight +\n    dimensions.stack.padding +\n    (sourceStack.states.length - branchPoint) *\n      (dimensions.state.height + dimensions.stack.stateSpacing);\n\n  // Layout branches horizontally, centered below branch point\n  const totalWidth =\n    branches.length * dimensions.stack.minWidth +\n    (branches.length - 1) * dimensions.spacing.branchGap;\n\n  let startX = sourcePosition.x + sourceBounds.width / 2 - totalWidth / 2;\n  const branchStartY = branchY + dimensions.spacing.branchGap;\n\n  for (const branch of branches) {\n    positions.set(branch.id, { x: startX, y: branchStartY });\n    startX += dimensions.stack.minWidth + dimensions.spacing.branchGap;\n  }\n\n  return positions;\n}\n", "/**\n * SVG-based renderer for state machine visualizations\n *\n * Uses SVG for crisp, scalable graphics with smooth CSS animations.\n */\n\nimport type {\n  RendererConfig,\n  ThemeConfig,\n  StateConfig,\n  StackConfig,\n  ToolConfig,\n  ArtifactConfig,\n  Point,\n  Rect,\n  ArrowOptions,\n  ElementRef,\n} from '../core/types.js';\nimport { getTheme, getStateColors } from '../utils/colors.js';\nimport {\n  dimensions,\n  getStatePositionInStack,\n  calculateStackHeight,\n  getCurvedArrowPath,\n  getStraightArrowPath,\n  getSteppedArrowPath,\n} from '../utils/layout.js';\n\n/**\n * SVG namespace\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Create an SVG element with attributes\n */\nfunction createSVGElement<K extends keyof SVGElementTagNameMap>(\n  tagName: K,\n  attributes: Record<string, string | number> = {}\n): SVGElementTagNameMap[K] {\n  const element = document.createElementNS(SVG_NS, tagName);\n  for (const [key, value] of Object.entries(attributes)) {\n    element.setAttribute(key, String(value));\n  }\n  return element;\n}\n\n/**\n * Generate a unique ID\n */\nlet idCounter = 0;\nfunction generateId(prefix: string): string {\n  return `${prefix}-${++idCounter}`;\n}\n\n/**\n * SVG Renderer class\n */\nexport class SVGRenderer {\n  private container: HTMLElement;\n  private svg: SVGSVGElement;\n  private defs: SVGDefsElement;\n  private mainGroup: SVGGElement;\n  private theme: ThemeConfig;\n  private width: number;\n  private height: number;\n  private padding: number;\n  private elements: Map<string, ElementRef> = new Map();\n  private resizeObserver: ResizeObserver | null = null;\n\n  // Pan and zoom state\n  private panX: number = 0;\n  private panY: number = 0;\n  private zoom: number = 1;\n  private isPanning: boolean = false;\n  private lastMouseX: number = 0;\n  private lastMouseY: number = 0;\n  private minZoom: number = 0.25;\n  private maxZoom: number = 4;\n\n  // Tooltip elements\n  private tooltipGroup: SVGGElement | null = null;\n  private tooltipVisible: boolean = false;\n\n  constructor(config: RendererConfig) {\n    // Resolve container\n    if (typeof config.container === 'string') {\n      const el = document.querySelector(config.container);\n      if (!el) {\n        throw new Error(`Container not found: ${config.container}`);\n      }\n      this.container = el as HTMLElement;\n    } else {\n      this.container = config.container;\n    }\n\n    // Initialize theme\n    this.theme = getTheme(config.theme || 'light');\n    this.padding = config.padding ?? 20;\n\n    // Get dimensions\n    this.width = config.width ?? (this.container.clientWidth || 800);\n    this.height = config.height ?? (this.container.clientHeight || 600);\n\n    // Create SVG\n    this.svg = createSVGElement('svg', {\n      width: this.width,\n      height: this.height,\n      viewBox: `0 0 ${this.width} ${this.height}`,\n    });\n    this.svg.style.fontFamily = this.theme.fontFamily;\n    this.svg.style.display = 'block';\n\n    // Create defs for gradients, filters, etc.\n    this.defs = createSVGElement('defs');\n    this.svg.appendChild(this.defs);\n    this.addFiltersAndGradients();\n\n    // Create main group for transforms\n    this.mainGroup = createSVGElement('g', {\n      transform: `translate(${this.padding}, ${this.padding})`,\n    });\n    this.svg.appendChild(this.mainGroup);\n\n    // Add background\n    this.drawBackground();\n\n    // Append to container\n    this.container.appendChild(this.svg);\n\n    // Setup responsive resizing\n    if (config.responsive) {\n      this.setupResponsive();\n    }\n\n    // Setup pan and zoom handlers\n    this.setupPanZoom();\n\n    // Create tooltip (added last so it's on top)\n    this.createTooltip();\n  }\n\n  /**\n   * Setup pan and zoom event handlers\n   */\n  private setupPanZoom(): void {\n    // Change cursor to indicate draggable\n    this.svg.style.cursor = 'grab';\n\n    // Mouse down - start panning\n    this.svg.addEventListener('mousedown', (e: MouseEvent) => {\n      // Only pan with left mouse button\n      if (e.button !== 0) return;\n\n      this.isPanning = true;\n      this.lastMouseX = e.clientX;\n      this.lastMouseY = e.clientY;\n      this.svg.style.cursor = 'grabbing';\n      e.preventDefault();\n    });\n\n    // Mouse move - pan if dragging\n    this.svg.addEventListener('mousemove', (e: MouseEvent) => {\n      if (!this.isPanning) return;\n\n      const dx = e.clientX - this.lastMouseX;\n      const dy = e.clientY - this.lastMouseY;\n\n      this.panX += dx / this.zoom;\n      this.panY += dy / this.zoom;\n\n      this.lastMouseX = e.clientX;\n      this.lastMouseY = e.clientY;\n\n      this.updateTransform();\n    });\n\n    // Mouse up - stop panning\n    this.svg.addEventListener('mouseup', () => {\n      this.isPanning = false;\n      this.svg.style.cursor = 'grab';\n    });\n\n    // Mouse leave - stop panning\n    this.svg.addEventListener('mouseleave', () => {\n      this.isPanning = false;\n      this.svg.style.cursor = 'grab';\n    });\n\n    // Wheel - zoom\n    this.svg.addEventListener('wheel', (e: WheelEvent) => {\n      e.preventDefault();\n\n      // Get mouse position relative to SVG\n      const rect = this.svg.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      // Calculate zoom factor\n      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;\n      const newZoom = Math.max(\n        this.minZoom,\n        Math.min(this.maxZoom, this.zoom * zoomFactor)\n      );\n\n      // Adjust pan to zoom towards mouse position\n      if (newZoom !== this.zoom) {\n        const zoomRatio = newZoom / this.zoom;\n        this.panX -= (mouseX / this.zoom) * (zoomRatio - 1);\n        this.panY -= (mouseY / this.zoom) * (zoomRatio - 1);\n        this.zoom = newZoom;\n        this.updateTransform();\n      }\n    });\n  }\n\n  /**\n   * Update the main group transform based on pan/zoom state\n   */\n  private updateTransform(): void {\n    this.mainGroup.setAttribute(\n      'transform',\n      `translate(${this.panX + this.padding}, ${this.panY + this.padding}) scale(${this.zoom})`\n    );\n  }\n\n  /**\n   * Reset pan and zoom to default\n   */\n  resetView(): void {\n    this.panX = 0;\n    this.panY = 0;\n    this.zoom = 1;\n    this.updateTransform();\n  }\n\n  /**\n   * Set zoom level programmatically\n   */\n  setZoom(level: number): void {\n    this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, level));\n    this.updateTransform();\n  }\n\n  /**\n   * Get current zoom level\n   */\n  getZoom(): number {\n    return this.zoom;\n  }\n\n  /**\n   * Create tooltip element\n   */\n  private createTooltip(): void {\n    this.tooltipGroup = createSVGElement('g', {\n      class: 'tooltip',\n      style: 'pointer-events: none; opacity: 0; transition: opacity 0.15s ease-out;',\n    });\n\n    // Tooltip background\n    const bg = createSVGElement('rect', {\n      class: 'tooltip-bg',\n      rx: 6,\n      ry: 6,\n      fill: 'rgba(45, 55, 72, 0.95)',\n      stroke: 'rgba(255, 255, 255, 0.1)',\n      'stroke-width': 1,\n    });\n    this.tooltipGroup.appendChild(bg);\n\n    // Tooltip text container\n    const textGroup = createSVGElement('g', {\n      class: 'tooltip-text',\n    });\n    this.tooltipGroup.appendChild(textGroup);\n\n    this.svg.appendChild(this.tooltipGroup);\n  }\n\n  /**\n   * Show tooltip with state information\n   */\n  showTooltip(\n    state: StateConfig,\n    screenX: number,\n    screenY: number\n  ): void {\n    if (!this.tooltipGroup) return;\n\n    const textGroup = this.tooltipGroup.querySelector('.tooltip-text') as SVGGElement;\n    const bg = this.tooltipGroup.querySelector('.tooltip-bg') as SVGRectElement;\n\n    // Clear previous text\n    while (textGroup.firstChild) {\n      textGroup.removeChild(textGroup.firstChild);\n    }\n\n    const padding = 12;\n    const lineHeight = 18;\n    let currentY = padding + 12;\n    let maxWidth = 0;\n\n    // State type (bold, larger)\n    const typeText = createSVGElement('text', {\n      x: padding,\n      y: currentY,\n      'font-size': 13,\n      'font-weight': '600',\n      fill: '#fff',\n    });\n    typeText.textContent = state.type;\n    textGroup.appendChild(typeText);\n    maxWidth = Math.max(maxWidth, state.type.length * 8);\n    currentY += lineHeight;\n\n    // Label (if exists and different from type)\n    if (state.label) {\n      const labelText = createSVGElement('text', {\n        x: padding,\n        y: currentY,\n        'font-size': 11,\n        fill: 'rgba(255, 255, 255, 0.8)',\n      });\n      labelText.textContent = state.label;\n      textGroup.appendChild(labelText);\n      maxWidth = Math.max(maxWidth, state.label.length * 6);\n      currentY += lineHeight;\n    }\n\n    // Additional data if present\n    if (state.data) {\n      currentY += 4; // Small gap\n      const dataEntries = Object.entries(state.data).slice(0, 3); // Limit to 3 entries\n      for (const [key, value] of dataEntries) {\n        const dataText = createSVGElement('text', {\n          x: padding,\n          y: currentY,\n          'font-size': 10,\n          fill: 'rgba(255, 255, 255, 0.6)',\n        });\n        const valueStr = String(value).substring(0, 30);\n        dataText.textContent = `${key}: ${valueStr}`;\n        textGroup.appendChild(dataText);\n        maxWidth = Math.max(maxWidth, (key.length + valueStr.length + 2) * 5.5);\n        currentY += lineHeight - 4;\n      }\n    }\n\n    // Size background\n    const tooltipWidth = Math.max(120, maxWidth + padding * 2);\n    const tooltipHeight = currentY + padding - 6;\n    bg.setAttribute('width', String(tooltipWidth));\n    bg.setAttribute('height', String(tooltipHeight));\n\n    // Position tooltip (offset from cursor, ensure visible)\n    const svgRect = this.svg.getBoundingClientRect();\n    let tooltipX = screenX - svgRect.left + 15;\n    let tooltipY = screenY - svgRect.top - tooltipHeight / 2;\n\n    // Keep within bounds\n    if (tooltipX + tooltipWidth > this.width - 10) {\n      tooltipX = screenX - svgRect.left - tooltipWidth - 15;\n    }\n    if (tooltipY < 10) {\n      tooltipY = 10;\n    }\n    if (tooltipY + tooltipHeight > this.height - 10) {\n      tooltipY = this.height - tooltipHeight - 10;\n    }\n\n    this.tooltipGroup.setAttribute('transform', `translate(${tooltipX}, ${tooltipY})`);\n    this.tooltipGroup.style.opacity = '1';\n    this.tooltipVisible = true;\n  }\n\n  /**\n   * Hide tooltip\n   */\n  hideTooltip(): void {\n    if (this.tooltipGroup && this.tooltipVisible) {\n      this.tooltipGroup.style.opacity = '0';\n      this.tooltipVisible = false;\n    }\n  }\n\n  /**\n   * Pan to center on a specific point\n   */\n  panTo(x: number, y: number): void {\n    this.panX = this.width / 2 / this.zoom - x;\n    this.panY = this.height / 2 / this.zoom - y;\n    this.updateTransform();\n  }\n\n  /**\n   * Add reusable SVG definitions\n   */\n  private addFiltersAndGradients(): void {\n    // Drop shadow filter\n    const dropShadow = createSVGElement('filter', {\n      id: 'drop-shadow',\n      x: '-20%',\n      y: '-20%',\n      width: '140%',\n      height: '140%',\n    });\n\n    const feGaussianBlur = createSVGElement('feGaussianBlur', {\n      in: 'SourceAlpha',\n      stdDeviation: '2',\n      result: 'blur',\n    });\n\n    const feOffset = createSVGElement('feOffset', {\n      in: 'blur',\n      dx: '0',\n      dy: '1',\n      result: 'offsetBlur',\n    });\n\n    const feFlood = createSVGElement('feFlood', {\n      'flood-color': 'rgba(0,0,0,0.15)',\n      result: 'color',\n    });\n\n    const feComposite = createSVGElement('feComposite', {\n      in: 'color',\n      in2: 'offsetBlur',\n      operator: 'in',\n      result: 'shadow',\n    });\n\n    const feMerge = createSVGElement('feMerge');\n    const feMergeNode1 = createSVGElement('feMergeNode', { in: 'shadow' });\n    const feMergeNode2 = createSVGElement('feMergeNode', { in: 'SourceGraphic' });\n    feMerge.appendChild(feMergeNode1);\n    feMerge.appendChild(feMergeNode2);\n\n    dropShadow.appendChild(feGaussianBlur);\n    dropShadow.appendChild(feOffset);\n    dropShadow.appendChild(feFlood);\n    dropShadow.appendChild(feComposite);\n    dropShadow.appendChild(feMerge);\n    this.defs.appendChild(dropShadow);\n\n    // Glow filter for highlights\n    const glow = createSVGElement('filter', {\n      id: 'glow',\n      x: '-50%',\n      y: '-50%',\n      width: '200%',\n      height: '200%',\n    });\n\n    const feGlow = createSVGElement('feGaussianBlur', {\n      stdDeviation: '3',\n      result: 'coloredBlur',\n    });\n\n    const feMergeGlow = createSVGElement('feMerge');\n    const feMergeGlowNode1 = createSVGElement('feMergeNode', { in: 'coloredBlur' });\n    const feMergeGlowNode2 = createSVGElement('feMergeNode', { in: 'SourceGraphic' });\n    feMergeGlow.appendChild(feMergeGlowNode1);\n    feMergeGlow.appendChild(feMergeGlowNode2);\n\n    glow.appendChild(feGlow);\n    glow.appendChild(feMergeGlow);\n    this.defs.appendChild(glow);\n\n    // Arrow marker\n    const arrowMarker = createSVGElement('marker', {\n      id: 'arrowhead',\n      markerWidth: '10',\n      markerHeight: '7',\n      refX: '9',\n      refY: '3.5',\n      orient: 'auto',\n      markerUnits: 'strokeWidth',\n    });\n\n    const arrowPath = createSVGElement('polygon', {\n      points: '0 0, 10 3.5, 0 7',\n      fill: this.theme.arrowColor,\n    });\n    arrowMarker.appendChild(arrowPath);\n    this.defs.appendChild(arrowMarker);\n  }\n\n  /**\n   * Draw background\n   */\n  private drawBackground(): void {\n    const bg = createSVGElement('rect', {\n      x: -this.padding,\n      y: -this.padding,\n      width: this.width,\n      height: this.height,\n      fill: this.theme.background,\n    });\n    this.mainGroup.insertBefore(bg, this.mainGroup.firstChild);\n  }\n\n  /**\n   * Setup responsive behavior\n   */\n  private setupResponsive(): void {\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect;\n        if (width > 0 && height > 0) {\n          this.resize(width, height);\n        }\n      }\n    });\n    this.resizeObserver.observe(this.container);\n  }\n\n  /**\n   * Clear all rendered elements\n   */\n  clear(): void {\n    while (this.mainGroup.children.length > 1) {\n      // Keep background\n      this.mainGroup.removeChild(this.mainGroup.lastChild!);\n    }\n    this.elements.clear();\n  }\n\n  /**\n   * Resize the canvas\n   */\n  resize(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.svg.setAttribute('width', String(width));\n    this.svg.setAttribute('height', String(height));\n    this.svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n  }\n\n  /**\n   * Get the SVG element\n   */\n  getElement(): SVGSVGElement {\n    return this.svg;\n  }\n\n  /**\n   * Get the theme\n   */\n  getTheme(): ThemeConfig {\n    return this.theme;\n  }\n\n  /**\n   * Get available drawing area\n   */\n  getDrawingArea(): Rect {\n    return {\n      x: 0,\n      y: 0,\n      width: this.width - this.padding * 2,\n      height: this.height - this.padding * 2,\n    };\n  }\n\n  /**\n   * Draw a state box\n   */\n  drawState(state: StateConfig, x: number, y: number): ElementRef {\n    const id = state.id || generateId('state');\n    const colors = getStateColors(state, this.theme);\n    const { width, height, borderRadius, padding, fontSize, labelFontSize } =\n      dimensions.state;\n\n    // Create group for the state\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'state-box',\n    });\n\n    // Background rectangle (flat design, no shadow)\n    const rect = createSVGElement('rect', {\n      x: 0,\n      y: 0,\n      width,\n      height,\n      rx: borderRadius,\n      ry: borderRadius,\n      fill: colors.background,\n      stroke: colors.border,\n      'stroke-width': 1.5,\n    });\n    group.appendChild(rect);\n\n    // State type label (centered like the blog)\n    const typeLabel = createSVGElement('text', {\n      x: width / 2,\n      y: height / 2 - (state.label ? 4 : 0),\n      'font-size': fontSize,\n      'font-weight': '500',\n      fill: colors.text,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    typeLabel.textContent = state.type;\n    group.appendChild(typeLabel);\n\n    // Optional detail label (centered)\n    if (state.label) {\n      const detailLabel = createSVGElement('text', {\n        x: width / 2,\n        y: height / 2 + 10,\n        'font-size': labelFontSize,\n        fill: colors.text,\n        opacity: 0.7,\n        'text-anchor': 'middle',\n        'dominant-baseline': 'middle',\n      });\n      // Truncate long labels\n      const maxLen = Math.floor((width - padding * 2) / 6);\n      detailLabel.textContent =\n        state.label.length > maxLen\n          ? state.label.substring(0, maxLen - 2) + '...'\n          : state.label;\n      group.appendChild(detailLabel);\n    }\n\n    this.mainGroup.appendChild(group);\n\n    // Add hover effect and tooltip\n    group.style.cursor = 'pointer';\n    (group as SVGGElement).addEventListener('mouseenter', (e: MouseEvent) => {\n      rect.setAttribute('stroke-width', '2.5');\n      rect.style.filter = 'brightness(1.05)';\n      this.showTooltip(state, e.clientX, e.clientY);\n    });\n    (group as SVGGElement).addEventListener('mousemove', (e: MouseEvent) => {\n      if (this.tooltipVisible) {\n        this.showTooltip(state, e.clientX, e.clientY);\n      }\n    });\n    (group as SVGGElement).addEventListener('mouseleave', () => {\n      rect.setAttribute('stroke-width', '1.5');\n      rect.style.filter = '';\n      this.hideTooltip();\n    });\n\n    const ref: ElementRef = {\n      type: 'state',\n      id,\n      element: group,\n      bounds: { x, y, width, height },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw a stack container with states\n   */\n  drawStack(stack: StackConfig, x: number, y: number): ElementRef {\n    const id = stack.id || generateId('stack');\n    const { padding: stackPadding, borderRadius, minWidth } =\n      dimensions.stack;\n    const { width: stateWidth } = dimensions.state;\n\n    const stackWidth = Math.max(minWidth, stateWidth + stackPadding * 2);\n    const stackHeight = calculateStackHeight(stack.states.length);\n\n    // Create group for the stack\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'stack-container',\n    });\n\n    // Stack background\n    const bg = createSVGElement('rect', {\n      x: 0,\n      y: 0,\n      width: stackWidth,\n      height: stackHeight,\n      rx: borderRadius,\n      ry: borderRadius,\n      fill: this.theme.stackBackground,\n      stroke: this.theme.stackBorderColor,\n      'stroke-width': 1,\n    });\n    group.appendChild(bg);\n\n    // Stack label\n    if (stack.label) {\n      const label = createSVGElement('text', {\n        x: stackWidth / 2,\n        y: 18,\n        'font-size': 14,\n        'font-weight': '600',\n        fill: this.theme.textColor,\n        'text-anchor': 'middle',\n        'dominant-baseline': 'middle',\n      });\n      label.textContent = stack.label;\n      group.appendChild(label);\n\n      // Separator line\n      const sep = createSVGElement('line', {\n        x1: stackPadding + 8,\n        y1: 32,\n        x2: stackWidth - stackPadding - 8,\n        y2: 32,\n        stroke: this.theme.stackBorderColor,\n        'stroke-width': 1,\n      });\n      group.appendChild(sep);\n    }\n\n    this.mainGroup.appendChild(group);\n\n    // Draw states within stack\n    const stateRefs: ElementRef[] = [];\n    for (let i = 0; i < stack.states.length; i++) {\n      const statePos = getStatePositionInStack(\n        x,\n        y,\n        stackWidth,\n        stack.states.length,\n        i\n      );\n      const stateRef = this.drawState(stack.states[i], statePos.x, statePos.y);\n      stateRefs.push(stateRef);\n    }\n\n    // Draw arrows between states\n    for (let i = 0; i < stateRefs.length - 1; i++) {\n      const from = stateRefs[i];\n      const to = stateRefs[i + 1];\n      this.drawStackArrow(\n        { x: from.bounds.x + from.bounds.width / 2, y: from.bounds.y },\n        { x: to.bounds.x + to.bounds.width / 2, y: to.bounds.y + to.bounds.height }\n      );\n    }\n\n    const ref: ElementRef = {\n      type: 'stack',\n      id,\n      element: group,\n      bounds: { x, y, width: stackWidth, height: stackHeight },\n      childRefs: stateRefs,\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw a small arrow between stack states\n   */\n  private drawStackArrow(from: Point, to: Point): void {\n    const arrow = createSVGElement('text', {\n      x: from.x,\n      y: (from.y + to.y) / 2 + 2,\n      'font-size': 10,\n      fill: this.theme.arrowColor,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    arrow.textContent = '\u2193';\n    this.mainGroup.appendChild(arrow);\n  }\n\n  /**\n   * Draw a tool box\n   */\n  drawTool(tool: ToolConfig, x: number, y: number, hidden: boolean = false): ElementRef {\n    const id = tool.id || generateId('tool');\n    const { width, height, borderRadius } = dimensions.tool;\n\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'tool-box',\n      style: hidden ? 'opacity: 0;' : '',\n    });\n\n    // Background (flat design, no shadow)\n    const rect = createSVGElement('rect', {\n      x: 0,\n      y: 0,\n      width,\n      height,\n      rx: borderRadius,\n      ry: borderRadius,\n      fill: tool.color || this.theme.toolColor,\n      stroke: this.theme.toolBorderColor,\n      'stroke-width': 1.5,\n    });\n    group.appendChild(rect);\n\n    // Tool name (centered, with optional icon)\n    const displayText = tool.icon ? `${tool.icon} ${tool.name}` : tool.name;\n    const name = createSVGElement('text', {\n      x: width / 2,\n      y: height / 2,\n      'font-size': 14,\n      'font-weight': '500',\n      fill: this.theme.textColor,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    name.textContent = displayText;\n    group.appendChild(name);\n\n    this.mainGroup.appendChild(group);\n\n    const ref: ElementRef = {\n      type: 'tool',\n      id,\n      element: group,\n      bounds: { x, y, width, height },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw an artifact (document with folded corner)\n   */\n  drawArtifact(artifact: ArtifactConfig, x: number, y: number, hidden: boolean = false): ElementRef {\n    const id = artifact.id || generateId('artifact');\n    const { width, height, foldSize, borderRadius } = dimensions.artifact;\n\n    const group = createSVGElement('g', {\n      id,\n      transform: `translate(${x}, ${y})`,\n      class: 'artifact',\n      style: hidden ? 'opacity: 0;' : '',\n    });\n\n    // Document shape with folded corner (top-right)\n    // Path: start top-left, go right (minus fold), diagonal fold, down, left, up\n    const docPath = `\n      M ${borderRadius} 0\n      L ${width - foldSize} 0\n      L ${width} ${foldSize}\n      L ${width} ${height - borderRadius}\n      Q ${width} ${height} ${width - borderRadius} ${height}\n      L ${borderRadius} ${height}\n      Q 0 ${height} 0 ${height - borderRadius}\n      L 0 ${borderRadius}\n      Q 0 0 ${borderRadius} 0\n      Z\n    `;\n\n    const doc = createSVGElement('path', {\n      d: docPath,\n      fill: artifact.color || '#e8f5e9',\n      stroke: '#4caf50',\n      'stroke-width': 1.5,\n    });\n    group.appendChild(doc);\n\n    // Folded corner triangle\n    const foldPath = `\n      M ${width - foldSize} 0\n      L ${width - foldSize} ${foldSize}\n      L ${width} ${foldSize}\n      Z\n    `;\n    const fold = createSVGElement('path', {\n      d: foldPath,\n      fill: '#c8e6c9',\n      stroke: '#4caf50',\n      'stroke-width': 1,\n    });\n    group.appendChild(fold);\n\n    // Icon based on artifact type\n    let icon = artifact.icon;\n    if (!icon) {\n      switch (artifact.type) {\n        case 'document':\n          icon = '\\u{1F4C4}'; // Page facing up\n          break;\n        case 'image':\n          icon = '\\u{1F5BC}'; // Framed picture\n          break;\n        case 'data':\n          icon = '\\u{1F4CA}'; // Bar chart\n          break;\n        case 'code':\n          icon = '\\u{1F4BB}'; // Laptop\n          break;\n        default:\n          icon = '\\u{1F4C1}'; // File folder\n      }\n    }\n\n    // Icon\n    const iconText = createSVGElement('text', {\n      x: width / 2,\n      y: height / 2 - 6,\n      'font-size': 20,\n      'text-anchor': 'middle',\n      'dominant-baseline': 'middle',\n    });\n    iconText.textContent = icon;\n    group.appendChild(iconText);\n\n    // Artifact name\n    const name = createSVGElement('text', {\n      x: width / 2,\n      y: height - 12,\n      'font-size': 10,\n      'font-weight': '500',\n      fill: '#2e7d32',\n      'text-anchor': 'middle',\n    });\n    // Truncate name if too long\n    const displayName = artifact.name.length > 12\n      ? artifact.name.substring(0, 10) + '...'\n      : artifact.name;\n    name.textContent = artifact.extension\n      ? `${displayName}.${artifact.extension}`\n      : displayName;\n    group.appendChild(name);\n\n    this.mainGroup.appendChild(group);\n\n    const ref: ElementRef = {\n      type: 'artifact',\n      id,\n      element: group,\n      bounds: { x, y, width, height },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Draw an arrow/connection between two points\n   */\n  drawArrow(options: ArrowOptions): ElementRef {\n    const id = generateId('arrow');\n    const { from, to, style = 'curved', strokeWidth = 2, color, dashArray, animated, hidden } = options;\n\n    const group = createSVGElement('g', {\n      id,\n      class: 'arrow',\n      style: hidden ? 'opacity: 0;' : '',\n    });\n\n    // Calculate path based on style\n    let pathD: string;\n    switch (style) {\n      case 'straight':\n        pathD = getStraightArrowPath(from, to);\n        break;\n      case 'stepped':\n        pathD = getSteppedArrowPath(from, to);\n        break;\n      case 'curved':\n      default:\n        pathD = getCurvedArrowPath(from, to);\n    }\n\n    // Draw path\n    const path = createSVGElement('path', {\n      d: pathD,\n      fill: 'none',\n      stroke: color || this.theme.arrowColor,\n      'stroke-width': strokeWidth,\n      'stroke-linecap': 'round',\n      'marker-end': options.showHead !== false ? 'url(#arrowhead)' : '',\n    });\n\n    if (dashArray) {\n      path.setAttribute('stroke-dasharray', dashArray);\n    }\n\n    if (animated) {\n      path.setAttribute('stroke-dasharray', '8 4');\n      path.style.animation = 'dash 0.5s linear infinite';\n    }\n\n    group.appendChild(path);\n    this.mainGroup.appendChild(group);\n\n    // Calculate bounding box\n    const minX = Math.min(from.x, to.x);\n    const minY = Math.min(from.y, to.y);\n    const maxX = Math.max(from.x, to.x);\n    const maxY = Math.max(from.y, to.y);\n\n    const ref: ElementRef = {\n      type: 'arrow',\n      id,\n      element: group,\n      bounds: { x: minX, y: minY, width: maxX - minX, height: maxY - minY },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Update an arrow's path to new endpoints (with animation)\n   */\n  async updateArrowPath(\n    arrowRef: ElementRef,\n    from: Point,\n    to: Point,\n    style: 'straight' | 'curved' | 'stepped' = 'curved',\n    duration: number = 300\n  ): Promise<void> {\n    const group = arrowRef.element as SVGGElement;\n    const path = group.querySelector('path');\n    if (!path) return;\n\n    // Calculate new path\n    let pathD: string;\n    switch (style) {\n      case 'straight':\n        pathD = getStraightArrowPath(from, to);\n        break;\n      case 'stepped':\n        pathD = getSteppedArrowPath(from, to);\n        break;\n      case 'curved':\n      default:\n        pathD = getCurvedArrowPath(from, to);\n    }\n\n    // Animate the path change using CSS transition\n    path.style.transition = `d ${duration}ms ease-in-out`;\n    path.setAttribute('d', pathD);\n\n    // Update bounds\n    const minX = Math.min(from.x, to.x);\n    const minY = Math.min(from.y, to.y);\n    const maxX = Math.max(from.x, to.x);\n    const maxY = Math.max(from.y, to.y);\n    arrowRef.bounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\n\n    await new Promise((resolve) => setTimeout(resolve, duration));\n  }\n\n  /**\n   * Draw a text label\n   */\n  drawLabel(\n    text: string,\n    x: number,\n    y: number,\n    options: {\n      fontSize?: number;\n      fontWeight?: string;\n      color?: string;\n      anchor?: 'start' | 'middle' | 'end';\n    } = {}\n  ): ElementRef {\n    const id = generateId('label');\n    const { fontSize = 12, fontWeight = 'normal', color, anchor = 'start' } = options;\n\n    const label = createSVGElement('text', {\n      id,\n      x,\n      y,\n      'font-size': fontSize,\n      'font-weight': fontWeight,\n      fill: color || this.theme.textColor,\n      'text-anchor': anchor,\n      'dominant-baseline': 'middle',\n    });\n    label.textContent = text;\n\n    this.mainGroup.appendChild(label);\n\n    const ref: ElementRef = {\n      type: 'label',\n      id,\n      element: label,\n      bounds: { x, y: y - fontSize / 2, width: text.length * fontSize * 0.6, height: fontSize },\n    };\n    this.elements.set(id, ref);\n    return ref;\n  }\n\n  /**\n   * Get an element reference by ID\n   */\n  getElementRef(id: string): ElementRef | undefined {\n    return this.elements.get(id);\n  }\n\n  /**\n   * Remove an element\n   */\n  removeElement(id: string): void {\n    const ref = this.elements.get(id);\n    if (ref) {\n      ref.element.remove();\n      this.elements.delete(id);\n    }\n  }\n\n  /**\n   * Animate an element's properties\n   */\n  async animate(\n    element: SVGElement,\n    props: Record<string, string | number>,\n    duration: number = 500\n  ): Promise<void> {\n    return new Promise((resolve) => {\n      // Use CSS transitions for smooth animation\n      element.style.transition = `all ${duration}ms ease-in-out`;\n\n      // Apply transform properties\n      if ('x' in props || 'y' in props) {\n        const currentTransform = element.getAttribute('transform') || '';\n        const match = currentTransform.match(/translate\\(([\\d.-]+),\\s*([\\d.-]+)\\)/);\n        const currentX = match ? parseFloat(match[1]) : 0;\n        const currentY = match ? parseFloat(match[2]) : 0;\n        const newX = 'x' in props ? props.x : currentX;\n        const newY = 'y' in props ? props.y : currentY;\n        element.setAttribute('transform', `translate(${newX}, ${newY})`);\n      }\n\n      // Apply other properties\n      for (const [key, value] of Object.entries(props)) {\n        if (key !== 'x' && key !== 'y') {\n          element.setAttribute(key, String(value));\n        }\n      }\n\n      setTimeout(resolve, duration);\n    });\n  }\n\n  /**\n   * Fade in an element\n   */\n  async fadeIn(element: SVGElement, duration: number = 300): Promise<void> {\n    element.style.opacity = '0';\n    element.style.transition = `opacity ${duration}ms ease-in`;\n\n    // Force reflow (getBoundingClientRect works on SVG elements)\n    element.getBoundingClientRect();\n\n    element.style.opacity = '1';\n    await new Promise((resolve) => setTimeout(resolve, duration));\n  }\n\n  /**\n   * Fade out an element\n   */\n  async fadeOut(element: SVGElement, duration: number = 300): Promise<void> {\n    element.style.transition = `opacity ${duration}ms ease-out`;\n    element.style.opacity = '0';\n    await new Promise((resolve) => setTimeout(resolve, duration));\n  }\n\n  /**\n   * Move an element to a new position\n   */\n  async moveTo(\n    element: SVGElement,\n    x: number,\n    y: number,\n    duration: number = 500\n  ): Promise<void> {\n    return this.animate(element, { x, y }, duration);\n  }\n\n  /**\n   * Highlight an element\n   */\n  async highlight(element: SVGElement, duration: number = 500): Promise<void> {\n    const originalFilter = element.getAttribute('filter') || '';\n    element.setAttribute('filter', 'url(#glow)');\n    await new Promise((resolve) => setTimeout(resolve, duration));\n    element.setAttribute('filter', originalFilter);\n  }\n\n  /**\n   * Add a pulsing effect to an element\n   */\n  pulse(element: SVGElement, duration: number = 1000): () => void {\n    // Use filter brightness instead of transform to avoid overriding translate\n    const animation = element.animate(\n      [\n        { filter: 'brightness(1)', opacity: 1 },\n        { filter: 'brightness(1.15)', opacity: 0.85 },\n        { filter: 'brightness(1)', opacity: 1 },\n      ],\n      {\n        duration,\n        iterations: Infinity,\n        easing: 'ease-in-out',\n      }\n    );\n\n    // Return cancel function\n    return () => animation.cancel();\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n    this.svg.remove();\n    this.elements.clear();\n  }\n}\n", "/**\n * Core Animator class for orchestrating state machine animations\n *\n * This is the main entry point for the library. It manages the rendering,\n * animation queue, and provides high-level animation APIs.\n */\n\nimport type {\n  RendererConfig,\n  StateConfig,\n  StackConfig,\n  AnimationConfig,\n  AnimatorEvent,\n  AnimatorEventCallback,\n  ToolExecutionAnimation,\n  ArtifactCreationAnimation,\n  TransitionDiagramAnimation,\n  BranchAnimation,\n  MultiStackInteraction,\n  Point,\n  ElementRef,\n} from './types.js';\nimport { SVGRenderer } from '../renderers/SVGRenderer.js';\nimport {\n  dimensions,\n  getStatePositionInStack,\n  getConnectionPoints,\n} from '../utils/layout.js';\n\n/**\n * Animation queue item\n */\ninterface QueuedAnimation {\n  fn: () => Promise<void>;\n  config?: AnimationConfig;\n}\n\n/**\n * Internal stack state tracking\n */\ninterface StackState {\n  config: StackConfig;\n  position: Point;\n  ref: ElementRef;\n  stateRefs: ElementRef[]; // Track individual state elements for animation\n}\n\n/**\n * State Machine Animator\n */\nexport class StateMachineAnimator {\n  private renderer: SVGRenderer;\n  private animationQueue: QueuedAnimation[] = [];\n  private isPlaying: boolean = false;\n  private isPaused: boolean = false;\n  private speedMultiplier: number = 1;\n  private stacks: Map<string, StackState> = new Map();\n  private eventListeners: Map<AnimatorEvent, Set<AnimatorEventCallback>> = new Map();\n  private defaultAnimationDuration: number = 500;\n\n  constructor(config: RendererConfig) {\n    this.renderer = new SVGRenderer(config);\n  }\n\n  // ===========================================================================\n  // Playback Control\n  // ===========================================================================\n\n  /**\n   * Play queued animations\n   */\n  async play(): Promise<void> {\n    if (this.isPlaying) return;\n    this.isPlaying = true;\n    this.isPaused = false;\n\n    this.emit('animationStart');\n\n    while (this.animationQueue.length > 0 && !this.isPaused) {\n      const animation = this.animationQueue.shift();\n      if (animation) {\n        await animation.fn();\n      }\n    }\n\n    this.isPlaying = false;\n    this.emit('animationComplete');\n  }\n\n  /**\n   * Pause animations\n   */\n  pause(): void {\n    this.isPaused = true;\n  }\n\n  /**\n   * Resume paused animations\n   */\n  resume(): void {\n    if (this.isPaused) {\n      this.isPaused = false;\n      this.play();\n    }\n  }\n\n  /**\n   * Stop and clear animation queue\n   */\n  stop(): void {\n    this.animationQueue = [];\n    this.isPlaying = false;\n    this.isPaused = false;\n  }\n\n  /**\n   * Reset the animator and clear canvas\n   */\n  reset(): void {\n    this.stop();\n    this.renderer.clear();\n    this.renderer.resetView();\n    this.stacks.clear();\n  }\n\n  /**\n   * Set animation speed multiplier\n   */\n  setSpeed(multiplier: number): void {\n    this.speedMultiplier = Math.max(0.1, Math.min(10, multiplier));\n  }\n\n  /**\n   * Reset pan and zoom to default view\n   */\n  resetView(): void {\n    this.renderer.resetView();\n  }\n\n  /**\n   * Set zoom level (0.25 to 4)\n   */\n  setZoom(level: number): void {\n    this.renderer.setZoom(level);\n  }\n\n  /**\n   * Get current zoom level\n   */\n  getZoom(): number {\n    return this.renderer.getZoom();\n  }\n\n  /**\n   * Get effective duration with speed multiplier\n   */\n  private getDuration(baseDuration?: number): number {\n    const duration = baseDuration ?? this.defaultAnimationDuration;\n    return duration / this.speedMultiplier;\n  }\n\n  // ===========================================================================\n  // Event Handling\n  // ===========================================================================\n\n  /**\n   * Subscribe to animator events\n   */\n  on(event: AnimatorEvent, callback: AnimatorEventCallback): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event)!.add(callback);\n  }\n\n  /**\n   * Unsubscribe from animator events\n   */\n  off(event: AnimatorEvent, callback: AnimatorEventCallback): void {\n    this.eventListeners.get(event)?.delete(callback);\n  }\n\n  /**\n   * Emit an event\n   */\n  private emit(event: AnimatorEvent, data?: unknown): void {\n    this.eventListeners.get(event)?.forEach((callback) => callback(data));\n  }\n\n  // ===========================================================================\n  // Stack Management\n  // ===========================================================================\n\n  /**\n   * Add a stack to the visualization\n   */\n  addStack(stack: StackConfig, position?: Point): ElementRef {\n    const pos = position ?? { x: 40, y: 40 };\n    const ref = this.renderer.drawStack(stack, pos.x, pos.y);\n\n    this.stacks.set(stack.id, {\n      config: { ...stack },\n      position: pos,\n      ref,\n      stateRefs: ref.childRefs ? [...ref.childRefs] : [], // Capture initial state refs\n    });\n\n    return ref;\n  }\n\n  /**\n   * Remove a stack\n   */\n  removeStack(stackId: string): void {\n    const state = this.stacks.get(stackId);\n    if (state) {\n      this.renderer.removeElement(stackId);\n      this.stacks.delete(stackId);\n    }\n  }\n\n  /**\n   * Get a stack's current configuration\n   */\n  getStack(stackId: string): StackConfig | undefined {\n    return this.stacks.get(stackId)?.config;\n  }\n\n  // ===========================================================================\n  // Low-Level Animation Primitives\n  // ===========================================================================\n\n  /**\n   * Push a state onto a stack (animated)\n   */\n  async pushState(stackId: string, state: StateConfig): Promise<void> {\n    const stackState = this.stacks.get(stackId);\n    if (!stackState) {\n      throw new Error(`Stack not found: ${stackId}`);\n    }\n\n    const { config, position, stateRefs } = stackState;\n    const duration = this.getDuration();\n\n    // Calculate stack width\n    const stackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    // Total states after push\n    const totalStates = config.states.length + 1;\n\n    // First, animate all existing states down to their new positions\n    const moveAnimations: Promise<void>[] = [];\n    for (let i = 0; i < stateRefs.length; i++) {\n      const existingRef = stateRefs[i];\n      // Each existing state keeps its logical index but there's now one more state\n      const newPos = getStatePositionInStack(\n        position.x,\n        position.y,\n        stackWidth,\n        totalStates,\n        i // Same index, but totalStates increased so it moves down\n      );\n      moveAnimations.push(\n        this.renderer.moveTo(\n          existingRef.element as SVGElement,\n          newPos.x,\n          newPos.y,\n          duration / 2\n        )\n      );\n    }\n\n    // Wait for all existing states to move down\n    if (moveAnimations.length > 0) {\n      await Promise.all(moveAnimations);\n    }\n\n    // Calculate position for new state (at the top of stack)\n    const newIndex = config.states.length; // Will be the topmost (newest) state\n    const newStatePos = getStatePositionInStack(\n      position.x,\n      position.y,\n      stackWidth,\n      totalStates,\n      newIndex\n    );\n\n    // Create state above the stack (for drop-in animation)\n    const startY = newStatePos.y - 50;\n    const stateRef = this.renderer.drawState(state, newStatePos.x, startY);\n\n    // Fade in\n    await this.renderer.fadeIn(stateRef.element as SVGElement, duration / 2);\n\n    // Animate down to position\n    await this.renderer.moveTo(\n      stateRef.element as SVGElement,\n      newStatePos.x,\n      newStatePos.y,\n      duration / 2\n    );\n\n    // Update stack state\n    config.states.push(state);\n    stateRefs.push(stateRef);\n\n    this.emit('stateChange', { stackId, state, action: 'push' });\n  }\n\n  /**\n   * Pop a state from a stack (animated)\n   */\n  async popState(stackId: string): Promise<StateConfig | undefined> {\n    const stackState = this.stacks.get(stackId);\n    if (!stackState || stackState.config.states.length === 0) {\n      return undefined;\n    }\n\n    const { config } = stackState;\n\n    // Get the top state\n    const topState = config.states[config.states.length - 1];\n\n    // Remove from config (animation could be added in the future)\n\n    config.states.pop();\n\n    this.emit('stateChange', { stackId, state: topState, action: 'pop' });\n\n    return topState;\n  }\n\n  /**\n   * Highlight a specific state in a stack\n   */\n  async highlightState(stackId: string, _index: number): Promise<void> {\n    const stackState = this.stacks.get(stackId);\n    if (!stackState) return;\n\n    // TODO: Would need element tracking to highlight specific state\n    // For now, highlight the entire stack\n    await this.renderer.highlight(\n      stackState.ref.element as SVGElement,\n      this.getDuration()\n    );\n  }\n\n  /**\n   * Draw a connection between two elements\n   */\n  async drawConnection(\n    fromRef: ElementRef,\n    toRef: ElementRef,\n    animated: boolean = true\n  ): Promise<ElementRef> {\n    const { from, to } = getConnectionPoints(\n      fromRef.bounds,\n      toRef.bounds,\n      'right',\n      'left'\n    );\n\n    const arrowRef = this.renderer.drawArrow({\n      from,\n      to,\n      style: 'curved',\n      animated,\n    });\n\n    if (animated) {\n      await this.renderer.fadeIn(arrowRef.element as SVGElement, this.getDuration());\n    }\n\n    return arrowRef;\n  }\n\n  // ===========================================================================\n  // High-Level Animation APIs\n  // ===========================================================================\n\n  /**\n   * Play a tool execution animation\n   */\n  async playToolExecution(config: ToolExecutionAnimation): Promise<void> {\n    const duration = this.getDuration(config.options?.executionDuration || 500);\n\n    // Clear and set up\n    this.renderer.clear();\n\n    // Draw the initial stack\n    const stackRef = this.addStack(config.stack, { x: 60, y: 60 });\n    const stackState = this.stacks.get(config.stack.id)!;\n\n    // Calculate stack width (used for positioning calculations)\n    const stackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    // Calculate tool position - place it to the right, vertically centered\n    const toolX = stackRef.bounds.x + stackRef.bounds.width + dimensions.spacing.toolGap;\n    const toolY = 100; // Fixed Y position for stability\n\n    // Draw tool box (hidden initially)\n    const toolRef = this.renderer.drawTool(config.tool, toolX, toolY, true);\n\n    await this.delay(duration / 2);\n\n    // Push pre-states if any (e.g., AskOracle, OracleResponse before ToolCall)\n    if (config.preStates && config.preStates.length > 0) {\n      for (const state of config.preStates) {\n        await this.pushState(config.stack.id, state);\n        await this.delay(duration / 3);\n      }\n    }\n\n    // Animate trigger state (ToolCall) pushing onto stack\n    await this.pushState(config.stack.id, config.triggerState);\n\n    // Calculate the actual position of the ToolCall state (top of stack after push)\n    const toolCallIndex = stackState.config.states.length - 1;\n    const toolCallPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      stackState.config.states.length,\n      toolCallIndex\n    );\n\n    await this.delay(duration / 4);\n\n    // Fade in the tool box as we're about to connect to it\n    await this.renderer.fadeIn(toolRef.element as SVGElement, duration / 3);\n\n    // Draw arrow from ToolCall to tool (outgoing request) - anchored to bottom of tool\n    const arrow1 = this.renderer.drawArrow({\n      from: {\n        x: toolCallPos.x + dimensions.state.width,\n        y: toolCallPos.y + dimensions.state.height / 2,\n      },\n      to: {\n        x: toolRef.bounds.x,\n        y: toolRef.bounds.y + toolRef.bounds.height * 0.7,\n      },\n      style: config.options?.arrowStyle || 'curved',\n    });\n\n    await this.renderer.fadeIn(arrow1.element as SVGElement, duration / 3);\n\n    // Pulse tool (execution)\n    const cancelPulse = this.renderer.pulse(toolRef.element as SVGElement, 300);\n    await this.delay(duration);\n    cancelPulse();\n\n    // Calculate where the ToolResult will appear (at the top of the stack after push)\n    const totalStatesAfterResult = stackState.config.states.length + 1;\n    const resultPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      totalStatesAfterResult,\n      totalStatesAfterResult - 1 // The new top state\n    );\n\n    // Draw arrow from tool back to where result will appear (incoming response) - anchored from top of tool\n    const arrow2 = this.renderer.drawArrow({\n      from: {\n        x: toolRef.bounds.x,\n        y: toolRef.bounds.y + toolRef.bounds.height * 0.3,\n      },\n      to: {\n        x: resultPos.x + dimensions.state.width,\n        y: resultPos.y + dimensions.state.height / 2,\n      },\n      style: config.options?.arrowStyle || 'curved',\n    });\n\n    await this.renderer.fadeIn(arrow2.element as SVGElement, duration / 3);\n\n    await this.delay(duration / 4);\n\n    // Calculate where ToolCall will be after ToolResult is pushed\n    const newToolCallPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      stackState.config.states.length + 1, // After result is added\n      toolCallIndex // ToolCall stays at same index\n    );\n\n    // Push result state AND update arrow1 in parallel\n    // The arrow follows ToolCall as it moves down\n    await Promise.all([\n      this.pushState(config.stack.id, config.resultState),\n      this.renderer.updateArrowPath(\n        arrow1,\n        {\n          x: newToolCallPos.x + dimensions.state.width,\n          y: newToolCallPos.y + dimensions.state.height / 2,\n        },\n        {\n          x: toolRef.bounds.x,\n          y: toolRef.bounds.y + toolRef.bounds.height * 0.7,\n        },\n        config.options?.arrowStyle || 'curved',\n        duration / 2\n      ),\n    ]);\n\n    // Push post-states if any, updating arrows as ToolCall and ToolResult move down\n    if (config.postStates && config.postStates.length > 0) {\n      await this.delay(duration / 2);\n\n      // ToolResult is right above ToolCall (index = toolCallIndex + 1)\n      const toolResultIndex = toolCallIndex + 1;\n\n      for (const state of config.postStates) {\n        // Calculate new positions after this state is pushed\n        const nextTotalStates = stackState.config.states.length + 1;\n        const nextToolCallPos = getStatePositionInStack(\n          stackState.position.x,\n          stackState.position.y,\n          stackWidth,\n          nextTotalStates,\n          toolCallIndex\n        );\n        const nextToolResultPos = getStatePositionInStack(\n          stackState.position.x,\n          stackState.position.y,\n          stackWidth,\n          nextTotalStates,\n          toolResultIndex\n        );\n\n        // Push state and update both arrows in parallel\n        await Promise.all([\n          this.pushState(config.stack.id, state),\n          this.renderer.updateArrowPath(\n            arrow1,\n            {\n              x: nextToolCallPos.x + dimensions.state.width,\n              y: nextToolCallPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: toolRef.bounds.x,\n              y: toolRef.bounds.y + toolRef.bounds.height * 0.7,\n            },\n            config.options?.arrowStyle || 'curved',\n            duration / 4\n          ),\n          this.renderer.updateArrowPath(\n            arrow2,\n            {\n              x: toolRef.bounds.x,\n              y: toolRef.bounds.y + toolRef.bounds.height * 0.3,\n            },\n            {\n              x: nextToolResultPos.x + dimensions.state.width,\n              y: nextToolResultPos.y + dimensions.state.height / 2,\n            },\n            config.options?.arrowStyle || 'curved',\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 3);\n      }\n    }\n\n    this.emit('animationComplete', { type: 'toolExecution' });\n  }\n\n  /**\n   * Play an artifact creation animation.\n   * Shows a tool call creating an external artifact that stays attached to the interaction.\n   */\n  async playArtifactCreation(config: ArtifactCreationAnimation): Promise<void> {\n    const duration = this.getDuration();\n    const artifactPosition = config.options?.artifactPosition || 'right';\n\n    // Clear and set up\n    this.renderer.clear();\n\n    // Draw the initial stack\n    const stackRef = this.addStack(config.stack, { x: 60, y: 60 });\n    const stackState = this.stacks.get(config.stack.id)!;\n\n    // Calculate stack width\n    const stackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    await this.delay(duration / 2);\n\n    // Push pre-states if any\n    if (config.preStates && config.preStates.length > 0) {\n      for (const state of config.preStates) {\n        await this.pushState(config.stack.id, state);\n        await this.delay(duration / 3);\n      }\n    }\n\n    // Push the creator state (e.g., ToolCall that creates the artifact)\n    await this.pushState(config.stack.id, config.creatorState);\n\n    // Get creator state position\n    const creatorIndex = stackState.config.states.length - 1;\n    const creatorPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      stackState.config.states.length,\n      creatorIndex\n    );\n\n    await this.delay(duration / 2);\n\n    // Calculate artifact position\n    const artifactX =\n      artifactPosition === 'right'\n        ? stackRef.bounds.x + stackRef.bounds.width + 60\n        : stackRef.bounds.x - dimensions.artifact.width - 60;\n    const artifactY = creatorPos.y - 10;\n\n    // Draw artifact (hidden initially)\n    const artifactRef = this.renderer.drawArtifact(config.artifact, artifactX, artifactY, true);\n\n    // Draw arrow from creator state to artifact\n    const arrowFrom = {\n      x: artifactPosition === 'right'\n        ? creatorPos.x + dimensions.state.width\n        : creatorPos.x,\n      y: creatorPos.y + dimensions.state.height / 2,\n    };\n    const arrowTo = {\n      x: artifactPosition === 'right'\n        ? artifactRef.bounds.x\n        : artifactRef.bounds.x + artifactRef.bounds.width,\n      y: artifactRef.bounds.y + artifactRef.bounds.height / 2,\n    };\n\n    const arrow = this.renderer.drawArrow({\n      from: arrowFrom,\n      to: arrowTo,\n      style: config.options?.arrowStyle || 'curved',\n      hidden: true,\n    });\n\n    // Fade in artifact and arrow together\n    await Promise.all([\n      this.renderer.fadeIn(artifactRef.element as SVGElement, duration / 2),\n      this.renderer.fadeIn(arrow.element as SVGElement, duration / 2),\n    ]);\n\n    await this.delay(duration / 2);\n\n    // Push result state\n    // Calculate new positions after result is pushed\n    const newTotalStates = stackState.config.states.length + 1;\n    const newCreatorPos = getStatePositionInStack(\n      stackState.position.x,\n      stackState.position.y,\n      stackWidth,\n      newTotalStates,\n      creatorIndex\n    );\n\n    // Push result and update arrow in parallel\n    await Promise.all([\n      this.pushState(config.stack.id, config.resultState),\n      this.renderer.updateArrowPath(\n        arrow,\n        {\n          x: artifactPosition === 'right'\n            ? newCreatorPos.x + dimensions.state.width\n            : newCreatorPos.x,\n          y: newCreatorPos.y + dimensions.state.height / 2,\n        },\n        arrowTo,\n        config.options?.arrowStyle || 'curved',\n        duration / 4\n      ),\n      this.renderer.moveTo(\n        artifactRef.element as SVGElement,\n        artifactX,\n        newCreatorPos.y - 10,\n        duration / 4\n      ),\n    ]);\n\n    // Update arrow endpoint to match new artifact position\n    const newArrowTo = {\n      x: arrowTo.x,\n      y: newCreatorPos.y - 10 + artifactRef.bounds.height / 2,\n    };\n\n    await this.renderer.updateArrowPath(\n      arrow,\n      {\n        x: artifactPosition === 'right'\n          ? newCreatorPos.x + dimensions.state.width\n          : newCreatorPos.x,\n        y: newCreatorPos.y + dimensions.state.height / 2,\n      },\n      newArrowTo,\n      config.options?.arrowStyle || 'curved',\n      100\n    );\n\n    // Push post-states if any, updating arrow and artifact position each time\n    if (config.postStates && config.postStates.length > 0) {\n      for (const state of config.postStates) {\n        const nextTotalStates = stackState.config.states.length + 1;\n        const nextCreatorPos = getStatePositionInStack(\n          stackState.position.x,\n          stackState.position.y,\n          stackWidth,\n          nextTotalStates,\n          creatorIndex\n        );\n\n        const nextArtifactY = nextCreatorPos.y - 10;\n        const nextArrowTo = {\n          x: arrowTo.x,\n          y: nextArtifactY + artifactRef.bounds.height / 2,\n        };\n\n        await Promise.all([\n          this.pushState(config.stack.id, state),\n          this.renderer.updateArrowPath(\n            arrow,\n            {\n              x: artifactPosition === 'right'\n                ? nextCreatorPos.x + dimensions.state.width\n                : nextCreatorPos.x,\n              y: nextCreatorPos.y + dimensions.state.height / 2,\n            },\n            nextArrowTo,\n            config.options?.arrowStyle || 'curved',\n            duration / 4\n          ),\n          this.renderer.moveTo(\n            artifactRef.element as SVGElement,\n            artifactX,\n            nextArtifactY,\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 3);\n      }\n    }\n\n    this.emit('animationComplete', { type: 'artifactCreation' });\n  }\n\n  /**\n   * Play a state transition diagram animation\n   */\n  async playTransitionDiagram(config: TransitionDiagramAnimation): Promise<void> {\n    const duration = this.getDuration();\n\n    // Clear canvas\n    this.renderer.clear();\n\n    // Determine which states to show\n    const allStates: StateConfig[] = [\n      { type: config.initialState },\n      ...config.transitions.map((t) => ({ type: t })),\n    ];\n\n    // Remove duplicates\n    const uniqueStates = Array.from(\n      new Map(allStates.map((s) => [s.type, s])).values()\n    );\n\n    // Layout states in a flow\n    const layout = config.layout || 'horizontal';\n    const spacing = layout === 'horizontal' ? 180 : 80;\n    const stateRefs: Map<string, ElementRef> = new Map();\n\n    let x = 60;\n    let y = 100;\n\n    for (const state of uniqueStates) {\n      const ref = this.renderer.drawState(state, x, y);\n      stateRefs.set(state.type, ref);\n\n      if (layout === 'horizontal') {\n        x += spacing;\n      } else {\n        y += spacing;\n      }\n    }\n\n    // Draw transition arrows\n    const transitionSequence = [config.initialState, ...config.transitions];\n    for (let i = 0; i < transitionSequence.length - 1; i++) {\n      const fromRef = stateRefs.get(transitionSequence[i]);\n      const toRef = stateRefs.get(transitionSequence[i + 1]);\n\n      if (fromRef && toRef) {\n        const fromSide = layout === 'horizontal' ? 'right' : 'bottom';\n        const toSide = layout === 'horizontal' ? 'left' : 'top';\n\n        const { from, to } = getConnectionPoints(\n          fromRef.bounds,\n          toRef.bounds,\n          fromSide as 'right' | 'left' | 'top' | 'bottom',\n          toSide as 'right' | 'left' | 'top' | 'bottom'\n        );\n\n        this.renderer.drawArrow({ from, to, style: 'straight' });\n      }\n    }\n\n    // Animate through transitions\n    for (let i = 0; i < transitionSequence.length; i++) {\n      const currentState = transitionSequence[i];\n      const ref = stateRefs.get(currentState);\n\n      if (ref) {\n        await this.renderer.highlight(ref.element as SVGElement, duration);\n        await this.delay(duration / 2);\n      }\n    }\n\n    // If syncing with stack, draw it alongside\n    if (config.syncWithStack) {\n      const stackX =\n        config.syncWithStack.position === 'right'\n          ? x + 100\n          : config.syncWithStack.position === 'left'\n            ? -200\n            : 60;\n      const stackY = config.syncWithStack.position === 'bottom' ? y + 100 : 60;\n\n      this.addStack(config.syncWithStack.stack, { x: stackX, y: stackY });\n    }\n\n    this.emit('animationComplete', { type: 'transitionDiagram' });\n  }\n\n  /**\n   * Play a branching animation\n   */\n  async playBranching(config: BranchAnimation): Promise<void> {\n    const duration = this.getDuration();\n\n    // Clear canvas\n    this.renderer.clear();\n\n    // Draw source stack\n    const sourceRef = this.addStack(config.sourceStack, { x: 200, y: 60 });\n\n    await this.delay(duration);\n\n    // Highlight branch point\n    await this.highlightState(config.sourceStack.id, config.branchPoint);\n\n    await this.delay(duration / 2);\n\n    // Calculate branch positions\n    const branchStartX = 80;\n    const branchY = sourceRef.bounds.y + sourceRef.bounds.height + 80;\n    const branchSpacing = config.layout?.spacing ?? dimensions.spacing.branchGap;\n\n    // Draw label for branching\n    this.renderer.drawLabel('Branches', sourceRef.bounds.x + sourceRef.bounds.width / 2, branchY - 30, {\n      anchor: 'middle',\n      fontSize: 14,\n      fontWeight: '600',\n    });\n\n    // Create branch stacks\n    let x = branchStartX;\n    for (const branch of config.branches) {\n      // Create stack config for branch\n      const branchStack: StackConfig = {\n        id: branch.id,\n        label: branch.label || `Branch ${branch.id}`,\n        states: [\n          ...config.sourceStack.states.slice(0, config.branchPoint + 1),\n          ...branch.additionalStates,\n        ],\n        branchId: branch.id,\n        parentStackId: config.sourceStack.id,\n      };\n\n      const branchRef = this.renderer.drawStack(branchStack, x, branchY);\n      await this.renderer.fadeIn(branchRef.element as SVGElement, duration);\n\n      // Draw connection line from source to branch\n      const connectionFrom = {\n        x: sourceRef.bounds.x + sourceRef.bounds.width / 2,\n        y: sourceRef.bounds.y + sourceRef.bounds.height,\n      };\n      const connectionTo = {\n        x: branchRef.bounds.x + branchRef.bounds.width / 2,\n        y: branchRef.bounds.y,\n      };\n\n      this.renderer.drawArrow({\n        from: connectionFrom,\n        to: connectionTo,\n        style: 'curved',\n        dashArray: dimensions.arrow.dashArray,\n      });\n\n      this.stacks.set(branch.id, {\n        config: branchStack,\n        position: { x, y: branchY },\n        ref: branchRef,\n        stateRefs: [],\n      });\n\n      x += branchRef.bounds.width + branchSpacing;\n\n      await this.delay(duration / 2);\n\n      this.emit('branchCreated', { branchId: branch.id });\n    }\n\n    this.emit('animationComplete', { type: 'branching' });\n  }\n\n  /**\n   * Play a multi-stack interaction animation\n   */\n  async playMultiStackInteraction(config: MultiStackInteraction): Promise<void> {\n    const duration = this.getDuration();\n    const childPosition = config.options?.childPosition || 'right';\n\n    // Clear canvas\n    this.renderer.clear();\n\n    // Draw parent stack\n    const parentRef = this.addStack(config.parentStack, { x: 60, y: 60 });\n    const parentStackState = this.stacks.get(config.parentStack.id)!;\n\n    // Calculate stack widths for position calculations\n    const parentStackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n    const childStackWidth = Math.max(\n      dimensions.stack.minWidth,\n      dimensions.state.width + dimensions.stack.padding * 2\n    );\n\n    // Calculate child position\n    const childX =\n      childPosition === 'right'\n        ? parentRef.bounds.x + parentRef.bounds.width + dimensions.spacing.stackGap\n        : parentRef.bounds.x;\n    const childY =\n      childPosition === 'below'\n        ? parentRef.bounds.y + parentRef.bounds.height + dimensions.spacing.stackGap\n        : parentRef.bounds.y;\n\n    // Draw child stack (initially empty)\n    const childStackConfig: StackConfig = {\n      ...config.childStack,\n      states: [],\n    };\n    this.addStack(childStackConfig, { x: childX, y: childY });\n    const childStackState = this.stacks.get(config.childStack.id)!;\n\n    await this.delay(duration);\n\n    // Animate parent execution steps before AgentCall\n    if (config.parentExecution && config.parentExecution.length > 0) {\n      if (config.options?.animateParentSteps !== false) {\n        for (const state of config.parentExecution) {\n          await this.pushState(config.parentStack.id, state);\n          await this.delay(duration / 2);\n        }\n      }\n    }\n\n    // Push call state onto parent\n    await this.pushState(config.parentStack.id, config.callState);\n\n    // Get AgentCall position for arrow start\n    const agentCallIndex = parentStackState.config.states.length - 1;\n    const agentCallPos = getStatePositionInStack(\n      parentStackState.position.x,\n      parentStackState.position.y,\n      parentStackWidth,\n      parentStackState.config.states.length,\n      agentCallIndex\n    );\n\n    await this.delay(duration / 2);\n\n    // Push first child state\n    if (config.childExecution.length > 0) {\n      await this.pushState(config.childStack.id, config.childExecution[0]);\n    }\n\n    // Calculate first child state position (it's at the top initially)\n    const firstChildStatePos = getStatePositionInStack(\n      childStackState.position.x,\n      childStackState.position.y,\n      childStackWidth,\n      1, // Only one state so far\n      0\n    );\n\n    // Draw arrow from AgentCall to first child state\n    const parentToChild = this.renderer.drawArrow({\n      from: {\n        x: agentCallPos.x + dimensions.state.width,\n        y: agentCallPos.y + dimensions.state.height / 2,\n      },\n      to: {\n        x: firstChildStatePos.x,\n        y: firstChildStatePos.y + dimensions.state.height / 2,\n      },\n      style: 'curved',\n      animated: true,\n    });\n\n    await this.renderer.fadeIn(parentToChild.element as SVGElement, duration / 2);\n\n    // Animate remaining child execution states\n    if (config.options?.animateChildSteps !== false && config.childExecution.length > 1) {\n      for (let i = 1; i < config.childExecution.length; i++) {\n        const state = config.childExecution[i];\n\n        // Calculate where first state will be after this push\n        const newFirstStatePos = getStatePositionInStack(\n          childStackState.position.x,\n          childStackState.position.y,\n          childStackWidth,\n          childStackState.config.states.length + 1,\n          0 // First state stays at index 0\n        );\n\n        // Push state and update arrow in parallel\n        await Promise.all([\n          this.pushState(config.childStack.id, state),\n          this.renderer.updateArrowPath(\n            parentToChild,\n            {\n              x: agentCallPos.x + dimensions.state.width,\n              y: agentCallPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: newFirstStatePos.x,\n              y: newFirstStatePos.y + dimensions.state.height / 2,\n            },\n            'curved',\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 2);\n      }\n    }\n\n    await this.delay(duration / 2);\n\n    // Get the position of the last child state (Finished)\n    const lastChildIndex = childStackState.config.states.length - 1;\n    const lastChildPos = getStatePositionInStack(\n      childStackState.position.x,\n      childStackState.position.y,\n      childStackWidth,\n      childStackState.config.states.length,\n      lastChildIndex\n    );\n\n    // Calculate where AgentResult will appear on parent stack\n    const agentResultPos = getStatePositionInStack(\n      parentStackState.position.x,\n      parentStackState.position.y,\n      parentStackWidth,\n      parentStackState.config.states.length + 1, // After result is added\n      parentStackState.config.states.length // New top state\n    );\n\n    // Draw arrow from last child state (Finished) to where AgentResult will be\n    const childToParent = this.renderer.drawArrow({\n      from: {\n        x: lastChildPos.x,\n        y: lastChildPos.y + dimensions.state.height / 2,\n      },\n      to: {\n        x: agentResultPos.x + dimensions.state.width,\n        y: agentResultPos.y + dimensions.state.height / 2,\n      },\n      style: 'curved',\n    });\n\n    await this.renderer.fadeIn(childToParent.element as SVGElement, duration / 2);\n\n    // Calculate where AgentCall will move to after result is pushed\n    const newAgentCallPos = getStatePositionInStack(\n      parentStackState.position.x,\n      parentStackState.position.y,\n      parentStackWidth,\n      parentStackState.config.states.length + 1,\n      agentCallIndex\n    );\n\n    // Push result onto parent and update parentToChild arrow in parallel\n    await Promise.all([\n      this.pushState(config.parentStack.id, config.resultState),\n      this.renderer.updateArrowPath(\n        parentToChild,\n        {\n          x: newAgentCallPos.x + dimensions.state.width,\n          y: newAgentCallPos.y + dimensions.state.height / 2,\n        },\n        {\n          x: firstChildStatePos.x,\n          y: getStatePositionInStack(\n            childStackState.position.x,\n            childStackState.position.y,\n            childStackWidth,\n            childStackState.config.states.length,\n            0\n          ).y + dimensions.state.height / 2,\n        },\n        'curved',\n        duration / 4\n      ),\n    ]);\n\n    // Animate parent completion steps after AgentResult\n    if (config.parentCompletion && config.parentCompletion.length > 0) {\n      await this.delay(duration / 2);\n\n      // Track indices - AgentResult was just pushed, so it's at the top\n      const agentResultIndex = parentStackState.config.states.length - 1;\n\n      // Get final positions of child states (they don't move anymore)\n      const finalFirstChildPos = getStatePositionInStack(\n        childStackState.position.x,\n        childStackState.position.y,\n        childStackWidth,\n        childStackState.config.states.length,\n        0\n      );\n      const finalLastChildPos = getStatePositionInStack(\n        childStackState.position.x,\n        childStackState.position.y,\n        childStackWidth,\n        childStackState.config.states.length,\n        childStackState.config.states.length - 1\n      );\n\n      for (const state of config.parentCompletion) {\n        // Calculate new positions after this state is pushed\n        const newTotalStates = parentStackState.config.states.length + 1;\n\n        const newAgentCallPos = getStatePositionInStack(\n          parentStackState.position.x,\n          parentStackState.position.y,\n          parentStackWidth,\n          newTotalStates,\n          agentCallIndex\n        );\n\n        const newAgentResultPos = getStatePositionInStack(\n          parentStackState.position.x,\n          parentStackState.position.y,\n          parentStackWidth,\n          newTotalStates,\n          agentResultIndex\n        );\n\n        // Push state and update both arrows in parallel\n        await Promise.all([\n          this.pushState(config.parentStack.id, state),\n          this.renderer.updateArrowPath(\n            parentToChild,\n            {\n              x: newAgentCallPos.x + dimensions.state.width,\n              y: newAgentCallPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: finalFirstChildPos.x,\n              y: finalFirstChildPos.y + dimensions.state.height / 2,\n            },\n            'curved',\n            duration / 4\n          ),\n          this.renderer.updateArrowPath(\n            childToParent,\n            {\n              x: finalLastChildPos.x,\n              y: finalLastChildPos.y + dimensions.state.height / 2,\n            },\n            {\n              x: newAgentResultPos.x + dimensions.state.width,\n              y: newAgentResultPos.y + dimensions.state.height / 2,\n            },\n            'curved',\n            duration / 4\n          ),\n        ]);\n\n        await this.delay(duration / 2);\n      }\n    }\n\n    this.emit('stackInteraction', {\n      parentId: config.parentStack.id,\n      childId: config.childStack.id,\n    });\n    this.emit('animationComplete', { type: 'multiStackInteraction' });\n  }\n\n  // ===========================================================================\n  // Utility Methods\n  // ===========================================================================\n\n  /**\n   * Wait for a duration\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get the renderer (for advanced usage)\n   */\n  getRenderer(): SVGRenderer {\n    return this.renderer;\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    this.stop();\n    this.renderer.destroy();\n    this.stacks.clear();\n    this.eventListeners.clear();\n  }\n}\n", "/**\n * Easing functions for smooth animations\n *\n * All functions take a progress value t in [0, 1] and return\n * a transformed value, also typically in [0, 1].\n */\n\nimport type { EasingFunction, EasingPreset } from '../core/types.js';\n\n/**\n * Linear - no easing\n */\nexport const linear: EasingFunction = (t) => t;\n\n/**\n * Quadratic easing\n */\nexport const easeInQuad: EasingFunction = (t) => t * t;\nexport const easeOutQuad: EasingFunction = (t) => t * (2 - t);\nexport const easeInOutQuad: EasingFunction = (t) =>\n  t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\n/**\n * Cubic easing\n */\nexport const easeInCubic: EasingFunction = (t) => t * t * t;\nexport const easeOutCubic: EasingFunction = (t) => --t * t * t + 1;\nexport const easeInOutCubic: EasingFunction = (t) =>\n  t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\n/**\n * Quartic easing\n */\nexport const easeInQuart: EasingFunction = (t) => t * t * t * t;\nexport const easeOutQuart: EasingFunction = (t) => 1 - --t * t * t * t;\nexport const easeInOutQuart: EasingFunction = (t) =>\n  t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n\n/**\n * Back easing - slight overshoot\n */\nconst c1 = 1.70158;\nconst c2 = c1 * 1.525;\nconst c3 = c1 + 1;\n\nexport const easeInBack: EasingFunction = (t) => c3 * t * t * t - c1 * t * t;\nexport const easeOutBack: EasingFunction = (t) =>\n  1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);\nexport const easeInOutBack: EasingFunction = (t) =>\n  t < 0.5\n    ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n    : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;\n\n/**\n * Elastic easing - springy effect\n */\nconst c4 = (2 * Math.PI) / 3;\nconst c5 = (2 * Math.PI) / 4.5;\n\nexport const easeInElastic: EasingFunction = (t) =>\n  t === 0\n    ? 0\n    : t === 1\n      ? 1\n      : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\n\nexport const easeOutElastic: EasingFunction = (t) =>\n  t === 0\n    ? 0\n    : t === 1\n      ? 1\n      : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n\nexport const easeInOutElastic: EasingFunction = (t) =>\n  t === 0\n    ? 0\n    : t === 1\n      ? 1\n      : t < 0.5\n        ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2\n        : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 +\n          1;\n\n/**\n * Bounce easing\n */\nexport const easeOutBounce: EasingFunction = (t) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (t < 1 / d1) {\n    return n1 * t * t;\n  } else if (t < 2 / d1) {\n    return n1 * (t -= 1.5 / d1) * t + 0.75;\n  } else if (t < 2.5 / d1) {\n    return n1 * (t -= 2.25 / d1) * t + 0.9375;\n  } else {\n    return n1 * (t -= 2.625 / d1) * t + 0.984375;\n  }\n};\n\nexport const easeInBounce: EasingFunction = (t) => 1 - easeOutBounce(1 - t);\nexport const easeInOutBounce: EasingFunction = (t) =>\n  t < 0.5\n    ? (1 - easeOutBounce(1 - 2 * t)) / 2\n    : (1 + easeOutBounce(2 * t - 1)) / 2;\n\n/**\n * Aliases for common easing names\n */\nexport const easeIn = easeInCubic;\nexport const easeOut = easeOutCubic;\nexport const easeInOut = easeInOutCubic;\n\n/**\n * Map of preset names to functions\n */\nexport const easingPresets: Record<EasingPreset, EasingFunction> = {\n  linear,\n  easeIn,\n  easeOut,\n  easeInOut,\n  easeInQuad,\n  easeOutQuad,\n  easeInOutQuad,\n  easeInCubic,\n  easeOutCubic,\n  easeInOutCubic,\n  easeInBack,\n  easeOutBack,\n  easeInOutBack,\n};\n\n/**\n * Get an easing function from a preset name or function\n */\nexport function getEasing(\n  easing: EasingFunction | EasingPreset | undefined\n): EasingFunction {\n  if (typeof easing === 'function') {\n    return easing;\n  }\n  if (typeof easing === 'string' && easing in easingPresets) {\n    return easingPresets[easing];\n  }\n  return easeInOutCubic; // Default\n}\n"],
  "mappings": "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",
  "names": ["newAgentCallPos"]
}
